
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Ear Training Hub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root{
      --bg:#0e1118;
      --card:#161b2a;
      --card2:#1e2440;
      --muted:#9aa4b2;
      --text:#e8ecf2;
      --btn:#273050;
      --btnHover:#313c63;
      --good:#1f4d3a;
      --bad:#4d1f2a;
      --radius:16px;
      --shadow:0 20px 40px rgba(0,0,0,.4);
      --font: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:var(--font);
      display:flex;
      justify-content:center;
      min-height:100vh;
      padding:24px;
    }
    .app{ width:900px; max-width:100%; }
    .card{
      background:var(--card);
      border-radius:var(--radius);
      padding:20px;
      box-shadow:var(--shadow);
    }
    h1{ margin:0 0 6px; font-size:22px; }
    .sub{ margin:0 0 16px; color:var(--muted); font-size:14px; }
    .hidden{ display:none !important; }

    /* Menu */
    .menuGrid{
      display:grid;
      grid-template-columns:repeat(3, 1fr);
      gap:12px;
      margin-top:12px;
    }
    @media(max-width:800px){
      .menuGrid{ grid-template-columns:1fr; }
    }
    .menuBtn{
      text-align:left;
      border:none;
      background:var(--card2);
      color:var(--text);
      padding:16px;
      border-radius:14px;
      cursor:pointer;
      transition:background .12s ease, transform .06s ease;
      box-shadow:0 8px 18px rgba(0,0,0,.25);
    }
    .menuBtn:hover{ background:#252d52; }
    .menuBtn:active{ transform:scale(.99); }
    .menuTitle{ font-weight:800; font-size:16px; margin-bottom:6px; }
    .menuDesc{ color:var(--muted); font-size:13px; line-height:1.35; }

    /* Shared UI */
    .top{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      flex-wrap:wrap;
      gap:10px;
    }
    .stats{
      display:flex;
      gap:10px;
      font-size:13px;
      color:var(--muted);
      flex-wrap:wrap;
      align-items:center;
    }
    .pill{
      background:#222840;
      padding:6px 10px;
      border-radius:999px;
    }
    .controls{
      margin-top:14px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    button.action{
      background:var(--btn);
      border:none;
      color:#fff;
      padding:10px 14px;
      border-radius:10px;
      cursor:pointer;
      font-weight:700;
    }
    button.action:hover{ background:var(--btnHover); }
    button.action:disabled{ opacity:.45; cursor:not-allowed; }

    .answers{
      margin-top:18px;
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:10px;
    }
    @media(max-width:600px){
      .answers{ grid-template-columns:1fr; }
    }
    .answer{
      background:var(--card2);
      border-radius:10px;
      padding:12px;
      border:none;
      color:var(--text);
      cursor:pointer;
      font-weight:700;
      text-align:left;
    }
    .answer:hover{ background:#252d52; }
    .answer:disabled{ opacity:.9; cursor:not-allowed; }
    .answer.correct{ background:var(--good) !important; }
    .answer.wrong{ background:var(--bad) !important; }

    .feedback{
      margin-top:14px;
      min-height:22px;
      font-size:14px;
      color:#cfd6e4;
    }

    .backRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-top:14px;
      border-top:1px solid rgba(255,255,255,.08);
      padding-top:14px;
    }
    .smallNote{ color:var(--muted); font-size:12px; line-height:1.35; }

    /* Panels */
    .twoCol{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media(max-width:700px){
      .twoCol{ grid-template-columns:1fr; }
    }
    .panel{
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      padding:12px;
    }
    .panelTitle{
      font-weight:800;
      margin-bottom:6px;
      font-size:13px;
      color:#d7deee;
    }
    .chips{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .chip{
      background:#222840;
      border-radius:999px;
      padding:6px 10px;
      font-size:12px;
      color:#cfd6e4;
    }

    /* Section 3: two clear columns */
    .eqAnswerGrid{
      display:grid;
      grid-template-columns: 2fr 1fr;
      gap:12px;
      margin-top:18px;
    }
    @media(max-width:700px){
      .eqAnswerGrid{ grid-template-columns:1fr; }
    }

    /* Small toggle buttons */
    .segToggle{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .segBtn{
      background:#222840;
      border:1px solid rgba(255,255,255,.10);
      color:#cfd6e4;
      padding:8px 10px;
      border-radius:999px;
      cursor:pointer;
      font-size:12px;
      font-weight:800;
    }
    .segBtn.active{
      outline:2px solid rgba(255,255,255,.28);
      color:#fff;
    }
    input[type="file"]{ display:none; }

    /* Loop UI */
    .loopRow{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
    }
    .loopLabel{
      font-size:12px;
      color:var(--muted);
      min-width:120px;
      font-weight:800;
    }
    .loopSlider{
      flex:1;
      min-width:220px;
    }
    .loopTime{
      font-size:12px;
      color:#cfd6e4;
      background:#222840;
      padding:6px 10px;
      border-radius:999px;
    }

    /* =========================
       FEEDBACK TRAINER (Graphic EQ)
    ========================== */
    .geqWrap{
      margin-top:16px;
      padding:12px;
      border-radius:12px;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
    }
    .geq{
      display:flex;
      gap:10px;
      align-items:flex-end;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .geqBand{
      width:74px;
      min-width:64px;
      background:var(--card2);
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      padding:10px 8px 8px;
      color:var(--text);
      cursor:pointer;
      font-weight:800;
      text-align:center;
      transition:background .12s ease, transform .06s ease;
    }
    .geqBand:hover{ background:#252d52; }
    .geqBand:active{ transform:scale(.99); }
    .geqBand:disabled{ opacity:.9; cursor:not-allowed; }
    .geqBand.correct{ background:var(--good) !important; }
    .geqBand.wrong{ background:var(--bad) !important; }

    .geqTrack{
      height:120px;
      border-radius:10px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      display:flex;
      align-items:center;
      justify-content:center;
      margin-bottom:8px;
      position:relative;
      overflow:hidden;
    }
    .geqTrack:before{
      content:"";
      position:absolute;
      top:8px; bottom:8px;
      left:50%;
      width:2px;
      transform:translateX(-50%);
      background:rgba(255,255,255,.10);
    }
    .geqKnob{
      width:34px;
      height:10px;
      border-radius:999px;
      background:#d7deee;
      opacity:.75;
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      top:50%;
    }
    .geqLabel{
      font-size:12px;
      color:#cfd6e4;
    }
  </style>
</head>

<body>
<div class="app">

  <!-- =========================
       FRONT PAGE / MENU
  ========================== -->
  <div class="card" id="view-menu">
    <h1>Ear Training Hub</h1>
    <p class="sub">Choose a training section.</p>

    <div class="menuGrid">
      <button class="menuBtn" id="go-frequency">
        <div class="menuTitle">Frequency Training</div>
        <div class="menuDesc">Identify pure tones. Multiple choice with scoring.</div>
      </button>

      <button class="menuBtn" id="go-interval">
        <div class="menuTitle">Interval Training</div>
        <div class="menuDesc">Recognize intervals (Semitone, Third, Fifth, Octave).</div>
      </button>

      <button class="menuBtn" id="go-section3">
        <div class="menuTitle">EQ Move Training</div>
        <div class="menuDesc">Compare Original vs Processed, identify band + boost/cut. (Noise or your track)</div>
      </button>

      <button class="menuBtn" id="go-stereo">
        <div class="menuTitle">Stereo vs Mono Identification</div>
        <div class="menuDesc">Identify Mono, Dual Mono, Wide Stereo, or Hard Pan. (Noise or your track)</div>
      </button>

      <!-- NEW: MID/SIDE -->
      <button class="menuBtn" id="go-midside">
        <div class="menuTitle">Is it Mid or Side?</div>
        <div class="menuDesc">Listen and decide whether you‚Äôre hearing Mid (center) or Side (width) information.</div>
      </button>

      <!-- NEW: PHASE -->
      <button class="menuBtn" id="go-phase">
        <div class="menuTitle">In Phase vs Out of Phase</div>
        <div class="menuDesc">Identify whether the stereo signal is in phase or polarity-flipped (out of phase).</div>
      </button>

      <!-- NEW: FEEDBACK TRAINER -->
      <button class="menuBtn" id="go-feedback">
        <div class="menuTitle">Feedback Trainer</div>
        <div class="menuDesc">Hear a ‚Äúring‚Äù and choose the graphic EQ band you‚Äôd cut.</div>
      </button>
    </div>

    <div class="backRow">
      <div class="smallNote"></div>
    </div>
  </div>

  <!-- =========================
       FREQUENCY TRAINING
  ========================== -->
  <div class="card hidden" id="view-frequency">
    <div class="top">
      <div>
        <h1>Frequency Training</h1>
        <p class="sub">Press Play, then choose the correct frequency.</p>
      </div>
      <div class="stats">
        <div class="pill">Score: <span id="score">0</span></div>
        <div class="pill">Question: <span id="qnum">1</span>/30</div>
        <div class="pill">Accuracy: <span id="acc">0%</span></div>
      </div>
    </div>

    <div class="controls">
      <button class="action" id="play">‚ñ∂ Play</button>
      <button class="action" id="replay" disabled>‚Üª Replay</button>
      <button class="action" id="next" disabled>Next ‚Üí</button>
      <button class="action" id="reset" style="margin-left:auto;">Reset</button>
    </div>

    <div class="answers" id="answers"></div>
    <div class="feedback" id="feedback"></div>

    <div class="backRow">
      <button class="action" id="backFromFrequency">‚Üê Back to Menu</button>
      <div class="smallNote">Tip: let students replay before answering.</div>
    </div>
  </div>

  <!-- =========================
       INTERVAL TRAINING
  ========================== -->
  <div class="card hidden" id="view-interval">
    <div class="top">
      <div>
        <h1>Interval Training</h1>
        <p class="sub">Press Play, then identify the interval (Semitone, Third, Fifth, Octave).</p>
      </div>
      <div class="stats">
        <div class="pill">Score: <span id="intScore">0</span></div>
        <div class="pill">Question: <span id="intQnum">1</span>/30</div>
        <div class="pill">Accuracy: <span id="intAcc">0%</span></div>
        <div class="pill">Mode: <span id="intModeLabel">Ascending</span></div>
      </div>
    </div>

    <div class="controls">
      <button class="action" id="intPlay">‚ñ∂ Play</button>
      <button class="action" id="intReplay" disabled>‚Üª Replay</button>
      <button class="action" id="intNext" disabled>Next ‚Üí</button>

      <button class="action" id="intMode" style="margin-left:auto;">Mode: Ascending</button>
      <button class="action" id="intReset">Reset</button>
    </div>

    <div class="answers" id="intAnswers"></div>
    <div class="feedback" id="intFeedback"></div>

    <div class="backRow">
      <button class="action" id="backFromInterval">‚Üê Back to Menu</button>
      <div class="smallNote">Tip: start with Ascending.</div>
    </div>
  </div>

  <!-- =========================
       SECTION 3: EQ MOVE TRAINING
  ========================== -->
  <div class="card hidden" id="view-section3">
    <div class="top">
      <div>
        <h1>EQ Move Training</h1>
        <p class="sub">
          Compare <b>Original</b> vs <b>Processed</b>, then pick the <b>band</b> and <b>boost</b>/<b>cut</b>.
        </p>

        <div class="segToggle" style="margin-top:10px;">
          <button class="segBtn active" id="eqUseNoiseBtn">Use Noise</button>
          <button class="segBtn" id="eqUseTrackBtn">Use My Track</button>
          <button class="segBtn" id="eqLoadBtn">Upload Track</button>
          <span class="chip" id="eqTrackLabel" style="opacity:.9;">No track loaded</span>
        </div>
        <input type="file" id="eqFile" accept="audio/*" />

        <div class="loopRow" id="eqLoopRow">
          <div class="loopLabel">Loop Start (4s)</div>
          <input class="loopSlider" type="range" id="eqLoop" min="0" max="0" step="0.01" value="0" disabled />
          <div class="loopTime" id="eqLoopTime">0.00s</div>
          <button class="action" id="eqPreview" disabled>Preview Loop</button>
        </div>
      </div>

      <div class="stats">
        <div class="pill">Score: <span id="eqScore">0</span></div>
        <div class="pill">Question: <span id="eqQnum">1</span>/30</div>
        <div class="pill">Accuracy: <span id="eqAcc">0%</span></div>
      </div>
    </div>

    <div class="twoCol">
      <div class="panel">
        <div class="panelTitle">Bands (broad mix zones)</div>
        <div class="chips">
          <div class="chip">Sub (20‚Äì60)</div>
          <div class="chip">Bass (60‚Äì200)</div>
          <div class="chip">Low-Mid (200‚Äì600)</div>
          <div class="chip">Mid (600‚Äì2k)</div>
          <div class="chip">High-Mid (2‚Äì6k)</div>
          <div class="chip">Air (8k+)</div>
        </div>
      </div>

      <div class="panel">
        <div class="panelTitle">How it works</div>
        <div class="smallNote">
          Use <b>Play A</b> (Original) and <b>Play B</b> (Processed).  
          When using your track, A/B plays <b>4 seconds</b> from the selected loop point.
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="action" id="eqPlay">‚ñ∂ Play AB</button>
      <button class="action" id="eqReplay" disabled>‚Üª Replay AB</button>
      <button class="action" id="eqNext" disabled>Next ‚Üí</button>

      <button class="action" id="eqPlayA" style="margin-left:auto;">Play A</button>
      <button class="action" id="eqPlayB">Play B</button>

      <button class="action" id="eqReset">Reset</button>
    </div>

    <div class="eqAnswerGrid">
      <div>
        <div class="panelTitle" style="margin:6px 0 8px;">Pick the band</div>
        <div class="answers" id="eqBandAnswers"></div>
      </div>
      <div>
        <div class="panelTitle" style="margin:6px 0 8px;">Boost or Cut?</div>
        <div class="answers" id="eqMoveAnswers"></div>
      </div>
    </div>

    <div class="feedback" id="eqFeedback"></div>

    <div class="backRow">
      <button class="action" id="backFromSection3">‚Üê Back to Menu</button>
      <div class="smallNote">Tip: widen difficulty by changing boost/cut amount later.</div>
    </div>
  </div>

  <!-- =========================
       SECTION 4: STEREO vs MONO IDENTIFICATION
  ========================== -->
  <div class="card hidden" id="view-stereo">
    <div class="top">
      <div>
        <h1>Stereo vs Mono Identification</h1>
        <p class="sub">Press Play, then identify: <b>Mono</b>, <b>Dual Mono</b>, <b>Wide Stereo</b>, or <b>Hard Pan</b>.</p>

        <div class="segToggle" style="margin-top:10px;">
          <button class="segBtn active" id="stUseNoiseBtn">Use Noise</button>
          <button class="segBtn" id="stUseTrackBtn">Use My Track</button>
          <button class="segBtn" id="stLoadBtn">Upload Track</button>
          <span class="chip" id="stTrackLabel" style="opacity:.9;">No track loaded</span>
        </div>
        <input type="file" id="stFile" accept="audio/*" />

        <div class="loopRow" id="stLoopRow">
          <div class="loopLabel">Loop Start (4s)</div>
          <input class="loopSlider" type="range" id="stLoop" min="0" max="0" step="0.01" value="0" disabled />
          <div class="loopTime" id="stLoopTime">0.00s</div>
          <button class="action" id="stPreview" disabled>Preview Loop</button>
        </div>
      </div>

      <div class="stats">
        <div class="pill">Score: <span id="stScore">0</span></div>
        <div class="pill">Question: <span id="stQnum">1</span>/30</div>
        <div class="pill">Accuracy: <span id="stAcc">0%</span></div>
      </div>
    </div>

    <div class="twoCol">
      <div class="panel">
        <div class="panelTitle">What to listen for</div>
        <div class="smallNote">
          <ul style="margin:8px 0 0 18px; color:var(--muted);">
            <li><b>Mono:</b> centered, same in both ears.</li>
            <li><b>Dual Mono:</b> mostly centered, subtle L/R differences.</li>
            <li><b>Wide Stereo:</b> noticeably wide.</li>
            <li><b>Hard Pan:</b> mostly one side.</li>
          </ul>
        </div>
      </div>
      <div class="panel">
        <div class="panelTitle">Quick compare tools</div>
        <div class="smallNote">
          Use <b>Play L</b> / <b>Play R</b> to check each side.  
          With your track, playback is <b>4 seconds</b> from the selected loop point.
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="action" id="stPlay">‚ñ∂ Play</button>
      <button class="action" id="stReplay" disabled>‚Üª Replay</button>
      <button class="action" id="stNext" disabled>Next ‚Üí</button>

      <button class="action" id="stPlayL" style="margin-left:auto;">Play L</button>
      <button class="action" id="stPlayR">Play R</button>

      <button class="action" id="stReset">Reset</button>
    </div>

    <div class="answers" id="stAnswers"></div>
    <div class="feedback" id="stFeedback"></div>

    <div class="backRow">
      <button class="action" id="backFromStereo">‚Üê Back to Menu</button>
      <div class="smallNote">Tip: headphones make this much easier.</div>
    </div>
  </div>

  <!-- =========================
       NEW SECTION 5: MID vs SIDE
  ========================== -->
  <div class="card hidden" id="view-midside">
    <div class="top">
      <div>
        <h1>Is it Mid or Side?</h1>
        <p class="sub">Press Play, then decide whether you are hearing <b>Mid</b> (center) or <b>Side</b> (width).</p>

        <div class="segToggle" style="margin-top:10px;">
          <button class="segBtn active" id="msUseToneBtn">Use Tone</button>
          <button class="segBtn" id="msUseTrackBtn">Use My Track</button>
          <button class="segBtn" id="msLoadBtn">Upload Track</button>
          <span class="chip" id="msTrackLabel" style="opacity:.9;">No track loaded</span>
        </div>
        <input type="file" id="msFile" accept="audio/*" />

        <div class="loopRow" id="msLoopRow">
          <div class="loopLabel">Loop Start (4s)</div>
          <input class="loopSlider" type="range" id="msLoop" min="0" max="0" step="0.01" value="0" disabled />
          <div class="loopTime" id="msLoopTime">0.00s</div>
          <button class="action" id="msPreview" disabled>Preview Loop</button>
        </div>
      </div>

      <div class="stats">
        <div class="pill">Score: <span id="msScore">0</span></div>
        <div class="pill">Question: <span id="msQnum">1</span>/30</div>
        <div class="pill">Accuracy: <span id="msAcc">0%</span></div>
      </div>
    </div>

    <div class="twoCol">
      <div class="panel">
        <div class="panelTitle">What it means</div>
        <div class="smallNote">
          <b>Mid</b> ‚âà L+R (center content). <br/>
          <b>Side</b> ‚âà L‚àíR (width/ambience/differences).
        </div>
      </div>
      <div class="panel">
        <div class="panelTitle">Tip</div>
        <div class="smallNote">
          Side often feels ‚Äúwide‚Äù and can sound odd if you focus on one ear.
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="action" id="msPlay">‚ñ∂ Play</button>
      <button class="action" id="msReplay" disabled>‚Üª Replay</button>
      <button class="action" id="msNext" disabled>Next ‚Üí</button>
      <button class="action" id="msReset" style="margin-left:auto;">Reset</button>
    </div>

    <div class="answers" id="msAnswers"></div>
    <div class="feedback" id="msFeedback"></div>

    <div class="backRow">
      <button class="action" id="backFromMidSide">‚Üê Back to Menu</button>
      <div class="smallNote">Tip: this gets easier with headphones.</div>
    </div>
  </div>

  <!-- =========================
       NEW SECTION 6: PHASE (IN vs OUT)
  ========================== -->
  <div class="card hidden" id="view-phase">
    <div class="top">
      <div>
        <h1>In Phase vs Out of Phase</h1>
        <p class="sub">Press Play, then decide if the signal is <b>In Phase</b> or <b>Out of Phase</b>.</p>

        <div class="segToggle" style="margin-top:10px;">
          <button class="segBtn active" id="phUseToneBtn">Use Tone</button>
          <button class="segBtn" id="phUseTrackBtn">Use My Track</button>
          <button class="segBtn" id="phLoadBtn">Upload Track</button>
          <span class="chip" id="phTrackLabel" style="opacity:.9;">No track loaded</span>
        </div>
        <input type="file" id="phFile" accept="audio/*" />

        <div class="loopRow" id="phLoopRow">
          <div class="loopLabel">Loop Start (4s)</div>
          <input class="loopSlider" type="range" id="phLoop" min="0" max="0" step="0.01" value="0" disabled />
          <div class="loopTime" id="phLoopTime">0.00s</div>
          <button class="action" id="phPreview" disabled>Preview Loop</button>
        </div>
      </div>

      <div class="stats">
        <div class="pill">Score: <span id="phScore">0</span></div>
        <div class="pill">Question: <span id="phQnum">1</span>/30</div>
        <div class="pill">Accuracy: <span id="phAcc">0%</span></div>
      </div>
    </div>

    <div class="twoCol">
      <div class="panel">
        <div class="panelTitle">What to listen for</div>
        <div class="smallNote">
          <ul style="margin:8px 0 0 18px; color:var(--muted);">
            <li><b>In phase:</b> solid center, strong low-end.</li>
            <li><b>Out of phase:</b> hollow/weak center, low-end collapses.</li>
          </ul>
        </div>
      </div>
      <div class="panel">
        <div class="panelTitle">Quick checks</div>
        <div class="smallNote">
          Try <b>Play L</b> and <b>Play R</b> to compare. With your track, it plays a 4s loop.
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="action" id="phPlay">‚ñ∂ Play</button>
      <button class="action" id="phReplay" disabled>‚Üª Replay</button>
      <button class="action" id="phNext" disabled>Next ‚Üí</button>

      <button class="action" id="phPlayL" style="margin-left:auto;">Play L</button>
      <button class="action" id="phPlayR">Play R</button>

      <button class="action" id="phReset">Reset</button>
    </div>

    <div class="answers" id="phAnswers"></div>
    <div class="feedback" id="phFeedback"></div>

    <div class="backRow">
      <button class="action" id="backFromPhase">‚Üê Back to Menu</button>
      <div class="smallNote">Tip: out-of-phase often sounds ‚Äúwide but empty.‚Äù</div>
    </div>
  </div>

  <!-- =========================
       NEW SECTION 7: FEEDBACK TRAINER
  ========================== -->
  <div class="card hidden" id="view-feedback">
    <div class="top">
      <div>
        <h1>Feedback Trainer</h1>
        <p class="sub">Listen for the ‚Äúring,‚Äù then click the <b>graphic EQ band</b> you‚Äôd cut.</p>
      </div>
      <div class="stats">
        <div class="pill">Score: <span id="fbScore">0</span></div>
        <div class="pill">Question: <span id="fbQnum">1</span>/30</div>
        <div class="pill">Accuracy: <span id="fbAcc">0%</span></div>
        <div class="pill">Mode: <span id="fbModeLabel">Noise + Ring</span></div>
      </div>
    </div>

    <div class="twoCol">
      <div class="panel">
        <div class="panelTitle">Live context</div>
        <div class="smallNote">
          This simulates a wedge/PA ‚Äúring‚Äù frequency. Your job is to pick the closest GEQ band to cut.
        </div>
      </div>
      <div class="panel">
        <div class="panelTitle">Modes</div>
        <div class="smallNote">
          <b>Noise + Ring:</b> super obvious resonant peak on bright noise.<br/>
          <b>Tone Only:</b> pure ring tone (easiest).
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="action" id="fbPlay">‚ñ∂ Play</button>
      <button class="action" id="fbReplay" disabled>‚Üª Replay</button>
      <button class="action" id="fbNext" disabled>Next ‚Üí</button>

      <button class="action" id="fbMode" style="margin-left:auto;">Mode: Noise + Ring</button>
      <button class="action" id="fbReset">Reset</button>
    </div>

    <div class="geqWrap">
      <div class="panelTitle" style="margin:0 0 8px;">Graphic EQ (pick the band to cut)</div>
      <div class="geq" id="fbEq"></div>
    </div>

    <div class="feedback" id="fbFeedback"></div>

    <div class="backRow">
      <button class="action" id="backFromFeedback">‚Üê Back to Menu</button>
      <div class="smallNote">Tip: in real life, start wide cuts then get narrower if needed.</div>
    </div>
  </div>

</div>

<audio id="player"></audio>

<script>
/* =====================================================
   VIEW ROUTER
===================================================== */
const views = {
  menu: document.getElementById("view-menu"),
  frequency: document.getElementById("view-frequency"),
  interval: document.getElementById("view-interval"),
  section3: document.getElementById("view-section3"),
  stereo: document.getElementById("view-stereo"),
  midside: document.getElementById("view-midside"),
  phase: document.getElementById("view-phase"),
  feedback: document.getElementById("view-feedback")
};

function showView(name){
  Object.values(views).forEach(v => v.classList.add("hidden"));
  views[name].classList.remove("hidden");
}

document.getElementById("go-frequency").onclick = () => showView("frequency");
document.getElementById("go-interval").onclick = () => showView("interval");
document.getElementById("go-section3").onclick = () => showView("section3");
document.getElementById("go-stereo").onclick = () => showView("stereo");
document.getElementById("go-midside").onclick = () => showView("midside");
document.getElementById("go-phase").onclick = () => showView("phase");
document.getElementById("go-feedback").onclick = () => showView("feedback");

document.getElementById("backFromFrequency").onclick = () => showView("menu");
document.getElementById("backFromInterval").onclick = () => showView("menu");
document.getElementById("backFromSection3").onclick = () => showView("menu");
document.getElementById("backFromStereo").onclick = () => showView("menu");
document.getElementById("backFromMidSide").onclick = () => showView("menu");
document.getElementById("backFromPhase").onclick = () => showView("menu");
document.getElementById("backFromFeedback").onclick = () => showView("menu");

/* =====================================================
   UTIL
===================================================== */
function shuffle(a){ return a.slice().sort(() => Math.random() - 0.5); }
function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
function fmtTime(s){ return (Math.round(s*100)/100).toFixed(2) + "s"; }

async function decodeFileToBuffer(file, audioCtx){
  const arr = await file.arrayBuffer();
  return await audioCtx.decodeAudioData(arr);
}

/* =====================================================
   FREQUENCY TRAINER
===================================================== */
const FILES = [
  { label:"80 Hz", file:"audio/1..mp3" },
  { label:"100 Hz", file:"audio/2_.mp3" },
  { label:"125 Hz", file:"audio/3..mp3" },
  { label:"250 Hz", file:"audio/4..mp3" },
  { label:"315 Hz", file:"audio/5..mp3" },
  { label:"400 Hz", file:"audio/6..mp3" },
  { label:"500 Hz", file:"audio/7_.mp3" },
  { label:"630 Hz", file:"audio/8..mp3" },
  { label:"800 Hz", file:"audio/9..mp3" },
  { label:"1 kHz", file:"audio/10_.mp3" },
  { label:"2 kHz", file:"audio/11_.mp3" },
  { label:"2.5 kHz", file:"audio/12..mp3" },
  { label:"3.15 kHz", file:"audio/13..mp3" },
  { label:"4 kHz", file:"audio/14..mp3" },
  { label:"5 kHz", file:"audio/15_.mp3" },
  { label:"6.3 kHz", file:"audio/16..mp3" },
  { label:"8 kHz", file:"audio/17..mp3" },
  { label:"10 kHz", file:"audio/18_.mp3" },
  { label:"12 kHz", file:"audio/19_.mp3" },
  { label:"14 kHz", file:"audio/20..mp3" },
  { label:"1 kHz", file:"audio/21_.mp3" },
  { label:"250 Hz", file:"audio/22..mp3" },
  { label:"500 Hz", file:"audio/23_.mp3" },
  { label:"2.15 kHz", file:"audio/24..mp3" },
  { label:"5 kHz", file:"audio/25_.mp3" },
  { label:"10 kHz", file:"audio/26_.mp3" },
  { label:"630 Hz", file:"audio/27..mp3" },
  { label:"125 Hz", file:"audio/28..mp3" },
  { label:"60 Hz", file:"audio/29_.mp3" },
  { label:"10 kHz", file:"audio/30_.mp3" }
];

const ANSWERS_PER_Q = 5;
let pool = [];
let current = null;
let locked = false;

let score = 0;
let answered = 0;
let correct = 0;

const player = document.getElementById("player");
const answersEl = document.getElementById("answers");
const feedbackEl = document.getElementById("feedback");
const scoreEl = document.getElementById("score");
const qnumEl = document.getElementById("qnum");
const accEl = document.getElementById("acc");

function refillPool(){ if(pool.length === 0) pool = shuffle(FILES); }

function updateStats(){
  scoreEl.textContent = String(score);
  qnumEl.textContent = String(Math.min(answered + 1, FILES.length));
  const pct = answered === 0 ? 0 : Math.round((correct/answered)*100);
  accEl.textContent = pct + "%";
}

function newQuestion(){
  locked = false;
  feedbackEl.textContent = "";
  document.getElementById("next").disabled = true;
  document.getElementById("replay").disabled = true;

  refillPool();
  current = pool.pop();

  const decoys = shuffle(FILES.filter(f => f !== current)).slice(0, ANSWERS_PER_Q - 1);
  const options = shuffle([current, ...decoys]);

  answersEl.innerHTML = "";
  options.forEach(item => {
    const b = document.createElement("button");
    b.className = "answer";
    b.textContent = item.label;
    b.onclick = () => selectAnswer(b, item);
    answersEl.appendChild(b);
  });

  updateStats();
}

function selectAnswer(btn, item){
  if(locked) return;
  locked = true;
  answered++;

  const buttons = document.querySelectorAll("#answers .answer");
  buttons.forEach(b => b.disabled = true);

  if(item === current){
    score++; correct++;
    btn.classList.add("correct");
    feedbackEl.innerHTML = `‚úÖ Correct ‚Äî <b>${current.label}</b>`;
  } else {
    btn.classList.add("wrong");
    feedbackEl.innerHTML = `‚ùå Incorrect ‚Äî Correct answer was <b>${current.label}</b>`;
    buttons.forEach(b => { if(b.textContent === current.label) b.classList.add("correct"); });
  }

  updateStats();
  document.getElementById("next").disabled = false;
}

document.getElementById("play").onclick = () => {
  if(!current) newQuestion();
  player.src = current.file;
  player.play();
  document.getElementById("replay").disabled = false;
};
document.getElementById("replay").onclick = () => { player.currentTime = 0; player.play(); };
document.getElementById("next").onclick = () => {
  if(answered >= FILES.length){
    feedbackEl.innerHTML = `üéâ Finished! Final Score: <b>${score}/${FILES.length}</b>`;
    document.getElementById("next").disabled = true;
    return;
  }
  newQuestion();
};
document.getElementById("reset").onclick = () => {
  score = 0; answered = 0; correct = 0;
  pool = [];
  updateStats();
  newQuestion();
};

/* =====================================================
   SECTION 3: EQ MOVE TRAINING  (UNCHANGED FROM YOUR VERSION)
===================================================== */
const EQ_TOTAL_Q = 30;
const EQ_TRACK_LOOP_LEN = 4.0;
const EQ_NOISE_SEG_LEN = 1.35;
const EQ_NOISE_GAP = 0.18;
const EQ_TRACK_GAP = 0.20;

const EQ_BANDS = [
  { id:"sub",     label:"Sub (20‚Äì60 Hz)",     type:"lowshelf",  freq:45,    q:0.7 },
  { id:"bass",    label:"Bass (60‚Äì200 Hz)",   type:"peaking",   freq:110,   q:1.0 },
  { id:"lowmid",  label:"Low-Mid (200‚Äì600)",  type:"peaking",   freq:350,   q:1.1 },
  { id:"mid",     label:"Mid (600‚Äì2k)",       type:"peaking",   freq:1200,  q:1.0 },
  { id:"highmid", label:"High-Mid (2‚Äì6k)",    type:"peaking",   freq:3500,  q:1.0 },
  { id:"air",     label:"Air (8k+)",          type:"highshelf", freq:11000, q:0.7 }
];

let eqScore = 0, eqAnswered = 0, eqCorrect = 0;
let eqLocked = false;

let eqCtx = null;
let eqNoiseBuffer = null;
let eqTrackBuffer = null;
let eqUseTrack = false;

let eqLoopStart = 0;
const eqLoopSlider = document.getElementById("eqLoop");
const eqLoopTime = document.getElementById("eqLoopTime");
const eqPreviewBtn = document.getElementById("eqPreview");

let eqCurrent = null;
let eqBandGuess = null;
let eqMoveGuess = null;
let eqLastSources = null;

const eqScoreEl = document.getElementById("eqScore");
const eqQnumEl  = document.getElementById("eqQnum");
const eqAccEl   = document.getElementById("eqAcc");
const eqFeedbackEl = document.getElementById("eqFeedback");

const eqBandAnswersEl = document.getElementById("eqBandAnswers");
const eqMoveAnswersEl = document.getElementById("eqMoveAnswers");

const eqUseNoiseBtn = document.getElementById("eqUseNoiseBtn");
const eqUseTrackBtn = document.getElementById("eqUseTrackBtn");
const eqLoadBtn = document.getElementById("eqLoadBtn");
const eqFile = document.getElementById("eqFile");
const eqTrackLabel = document.getElementById("eqTrackLabel");

function eqUpdateStats(){
  eqScoreEl.textContent = String(eqScore);
  eqQnumEl.textContent = String(Math.min(eqAnswered + 1, EQ_TOTAL_Q));
  const pct = eqAnswered === 0 ? 0 : Math.round((eqCorrect/eqAnswered)*100);
  eqAccEl.textContent = pct + "%";
}

function eqEnsureAudio(){
  if(eqCtx) return;
  eqCtx = new (window.AudioContext || window.webkitAudioContext)();

  const seconds = 3;
  const length = Math.floor(eqCtx.sampleRate * seconds);
  const buffer = eqCtx.createBuffer(1, length, eqCtx.sampleRate);
  const out = buffer.getChannelData(0);

  let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
  for(let i=0;i<length;i++){
    const white = Math.random()*2 - 1;
    b0 = 0.99886*b0 + white*0.0555179;
    b1 = 0.99332*b1 + white*0.0750759;
    b2 = 0.96900*b2 + white*0.1538520;
    b3 = 0.86650*b3 + white*0.3104856;
    b4 = 0.55000*b4 + white*0.5329522;
    b5 = -0.7616*b5 - white*0.0168980;
    const pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white*0.5362;
    b6 = white*0.115926;
    out[i] = pink * 0.11;
  }
  eqNoiseBuffer = buffer;
}

function eqStopPlayback(){
  try{
    if(eqLastSources){
      eqLastSources.forEach(s => { try{ s.stop(); }catch(e){} });
      eqLastSources = null;
    }
  }catch(e){}
}

function eqGetSourceBuffer(){
  if(eqUseTrack && eqTrackBuffer) return eqTrackBuffer;
  return eqNoiseBuffer;
}

function eqConfigureLoopUI(){
  const hasTrack = !!eqTrackBuffer;
  const loopLen = hasTrack ? Math.min(EQ_TRACK_LOOP_LEN, eqTrackBuffer.duration) : EQ_TRACK_LOOP_LEN;

  if(hasTrack){
    const maxStart = Math.max(0, eqTrackBuffer.duration - loopLen);
    eqLoopStart = clamp(eqLoopStart, 0, maxStart);

    eqLoopSlider.disabled = false;
    eqLoopSlider.min = "0";
    eqLoopSlider.max = String(maxStart);
    eqLoopSlider.step = "0.01";
    eqLoopSlider.value = String(eqLoopStart);
    eqLoopTime.textContent = fmtTime(eqLoopStart);
    eqPreviewBtn.disabled = !eqUseTrack;
  } else {
    eqLoopStart = 0;
    eqLoopSlider.disabled = true;
    eqLoopSlider.min = "0";
    eqLoopSlider.max = "0";
    eqLoopSlider.value = "0";
    eqLoopTime.textContent = "0.00s";
    eqPreviewBtn.disabled = true;
  }
}

eqLoopSlider.oninput = (e) => {
  eqLoopStart = parseFloat(e.target.value || "0");
  eqLoopTime.textContent = fmtTime(eqLoopStart);
};

function eqBuildAnswerButtons(){
  eqBandAnswersEl.innerHTML = "";
  EQ_BANDS.forEach(band => {
    const btn = document.createElement("button");
    btn.className = "answer";
    btn.textContent = band.label;
    btn.onclick = () => eqPickBand(btn, band);
    eqBandAnswersEl.appendChild(btn);
  });

  eqMoveAnswersEl.innerHTML = "";
  ["Boost", "Cut"].forEach(txt => {
    const btn = document.createElement("button");
    btn.className = "answer";
    btn.textContent = txt;
    btn.onclick = () => eqPickMove(btn, txt.toLowerCase());
    eqMoveAnswersEl.appendChild(btn);
  });
}

function eqNewQuestion(){
  eqLocked = false;
  eqBandGuess = null;
  eqMoveGuess = null;
  eqFeedbackEl.textContent = "";
  document.getElementById("eqNext").disabled = true;
  document.getElementById("eqReplay").disabled = true;

  const band = EQ_BANDS[Math.floor(Math.random()*EQ_BANDS.length)];
  const move = Math.random() < 0.5 ? "boost" : "cut";
  eqCurrent = { band, move };

  [...document.querySelectorAll("#eqBandAnswers .answer, #eqMoveAnswers .answer")]
    .forEach(b => {
      b.disabled = false;
      b.classList.remove("correct","wrong");
      b.style.outline = "";
    });

  eqUpdateStats();
}

function eqPickBand(btn, band){
  if(eqLocked) return;
  eqBandGuess = band;

  [...document.querySelectorAll("#eqBandAnswers .answer")].forEach(b=>{
    b.classList.remove("correct","wrong");
    b.style.outline = "";
  });
  btn.style.outline = "2px solid rgba(255,255,255,.35)";
  eqMaybeFinalize();
}

function eqPickMove(btn, move){
  if(eqLocked) return;
  eqMoveGuess = move;

  [...document.querySelectorAll("#eqMoveAnswers .answer")].forEach(b=>{
    b.classList.remove("correct","wrong");
    b.style.outline = "";
  });
  btn.style.outline = "2px solid rgba(255,255,255,.35)";
  eqMaybeFinalize();
}

function eqMaybeFinalize(){
  if(!eqBandGuess || !eqMoveGuess) return;

  eqLocked = true;
  eqAnswered++;

  const bandCorrect = eqBandGuess.id === eqCurrent.band.id;
  const moveCorrect = eqMoveGuess === eqCurrent.move;

  const bandButtons = [...document.querySelectorAll("#eqBandAnswers .answer")];
  const moveButtons = [...document.querySelectorAll("#eqMoveAnswers .answer")];

  [...bandButtons, ...moveButtons].forEach(b=>{
    b.disabled = true;
    b.style.outline = "";
  });

  bandButtons.forEach(b=>{
    if(b.textContent === eqCurrent.band.label) b.classList.add("correct");
  });
  moveButtons.forEach(b=>{
    if(b.textContent.toLowerCase() === (eqCurrent.move === "boost" ? "boost" : "cut")) b.classList.add("correct");
  });

  if(!bandCorrect){
    bandButtons.forEach(b=>{
      if(eqBandGuess && b.textContent === eqBandGuess.label) b.classList.add("wrong");
    });
  }
  if(!moveCorrect){
    moveButtons.forEach(b=>{
      if(eqMoveGuess && b.textContent.toLowerCase() === eqMoveGuess) b.classList.add("wrong");
    });
  }

  let gained = 0;
  if(bandCorrect) gained++;
  if(moveCorrect) gained++;
  eqScore += gained;
  if(gained === 2) eqCorrect++;

  const moveWord = eqCurrent.move === "boost" ? "Boost" : "Cut";
  const resultIcon = gained === 2 ? "‚úÖ" : (gained === 1 ? "üü®" : "‚ùå");

  eqFeedbackEl.innerHTML =
    `${resultIcon} Correct: <b>${eqCurrent.band.label}</b> + <b>${moveWord}</b> ` +
    `<span style="color:var(--muted);">(+${gained} point${gained===1?"":"s"})</span>`;

  eqUpdateStats();
  document.getElementById("eqNext").disabled = false;
}

function eqPlay(mode="AB"){
  eqEnsureAudio();
  eqStopPlayback();
  if(!eqCurrent) eqNewQuestion();
  if(eqCtx.state === "suspended") eqCtx.resume();

  const buffer = eqGetSourceBuffer();
  if(!buffer){
    eqFeedbackEl.innerHTML = `‚ö†Ô∏è Audio not ready yet. Try again.`;
    return;
  }

  const usingTrack = (eqUseTrack && eqTrackBuffer);
  const loopLen = usingTrack ? Math.min(EQ_TRACK_LOOP_LEN, buffer.duration) : EQ_NOISE_SEG_LEN;
  const gap = usingTrack ? EQ_TRACK_GAP : EQ_NOISE_GAP;

  const src = eqCtx.createBufferSource();
  src.buffer = buffer;

  const dryGain = eqCtx.createGain();
  const wetGain = eqCtx.createGain();

  const filter = eqCtx.createBiquadFilter();
  filter.type = eqCurrent.band.type;
  filter.frequency.value = eqCurrent.band.freq;
  filter.Q.value = eqCurrent.band.q;
  filter.gain.value = (eqCurrent.move === "boost" ? 7 : -7);

  const master = eqCtx.createGain();
  master.gain.value = 0.0001;
  master.connect(eqCtx.destination);

  src.connect(dryGain); dryGain.connect(master);
  src.connect(filter);  filter.connect(wetGain); wetGain.connect(master);

  const now = eqCtx.currentTime;
  const startT = now + 0.02;

  const offset = usingTrack ? clamp(eqLoopStart, 0, Math.max(0, buffer.duration - loopLen)) : 0;

  let aStart = startT;
  let bStart = startT + loopLen + gap;
  let endT = startT + loopLen;

  dryGain.gain.setValueAtTime(0.0001, now);
  wetGain.gain.setValueAtTime(0.0001, now);

  if(mode === "A"){
    dryGain.gain.setValueAtTime(0.85, aStart);
    wetGain.gain.setValueAtTime(0.0001, aStart);
    endT = aStart + loopLen;
  } else if(mode === "B"){
    dryGain.gain.setValueAtTime(0.0001, aStart);
    wetGain.gain.setValueAtTime(0.85, aStart);
    endT = aStart + loopLen;
  } else {
    dryGain.gain.setValueAtTime(0.85, aStart);
    dryGain.gain.setValueAtTime(0.0001, bStart);

    wetGain.gain.setValueAtTime(0.0001, aStart);
    wetGain.gain.setValueAtTime(0.85, bStart);

    endT = bStart + loopLen;
  }

  master.gain.setValueAtTime(0.0001, now);
  master.gain.exponentialRampToValueAtTime(0.75, startT + 0.03);
  master.gain.setValueAtTime(0.75, endT - 0.08);
  master.gain.exponentialRampToValueAtTime(0.0001, endT);

  if(usingTrack){
    src.start(aStart, offset, (mode === "AB") ? (2*loopLen + gap) : loopLen);
    src.stop(endT + 0.02);
  } else {
    src.start(aStart);
    src.stop(endT + 0.02);
  }

  eqLastSources = [src];
  document.getElementById("eqReplay").disabled = false;
}

document.getElementById("eqPlay").onclick = () => eqPlay("AB");
document.getElementById("eqReplay").onclick = () => eqPlay("AB");
document.getElementById("eqPlayA").onclick = () => eqPlay("A");
document.getElementById("eqPlayB").onclick = () => eqPlay("B");

document.getElementById("eqNext").onclick = () => {
  if(eqAnswered >= EQ_TOTAL_Q){
    eqFeedbackEl.innerHTML = `üéâ Finished! Final Score: <b>${eqScore}/${EQ_TOTAL_Q*2}</b> (2 points per question)`;
    document.getElementById("eqNext").disabled = true;
    return;
  }
  eqNewQuestion();
};

document.getElementById("eqReset").onclick = () => {
  eqScore = 0; eqAnswered = 0; eqCorrect = 0;
  eqUpdateStats();
  eqNewQuestion();
};

function eqRefreshToggleUI(){
  eqUseNoiseBtn.classList.toggle("active", !eqUseTrack);
  eqUseTrackBtn.classList.toggle("active", !!eqUseTrack);
  if(eqUseTrack && !eqTrackBuffer) eqTrackLabel.textContent = "No track loaded";
  eqConfigureLoopUI();
}

eqUseNoiseBtn.onclick = () => { eqUseTrack = false; eqRefreshToggleUI(); };
eqUseTrackBtn.onclick = () => { eqUseTrack = true;  eqRefreshToggleUI(); };
eqLoadBtn.onclick = () => { eqEnsureAudio(); eqFile.click(); };

eqFile.onchange = async (e) => {
  const file = e.target.files?.[0];
  if(!file) return;
  eqEnsureAudio();
  try{
    eqTrackLabel.textContent = "Loading‚Ä¶";
    const buf = await decodeFileToBuffer(file, eqCtx);
    eqTrackBuffer = buf;
    eqUseTrack = true;
    eqTrackLabel.textContent = file.name;
    eqLoopStart = 0;
    eqRefreshToggleUI();
  }catch(err){
    eqTrackBuffer = null;
    eqTrackLabel.textContent = "Could not load track";
    eqFeedbackEl.innerHTML = `‚ö†Ô∏è Could not decode this file. Try WAV/MP3.`;
    eqUseTrack = false;
    eqRefreshToggleUI();
  }
};

eqPreviewBtn.onclick = () => {
  if(!eqTrackBuffer) return;
  eqUseTrack = true;
  eqRefreshToggleUI();
  eqPlay("A");
};

/* =====================================================
   INTERVAL TRAINER
===================================================== */
const INT_TOTAL_Q = 30;
const INTERVALS = [
  { id:"semitone", label:"Semitone", semitones:1 },
  { id:"third",    label:"Third",    semitones:4 },
  { id:"fifth",    label:"Fifth",    semitones:7 },
  { id:"octave",   label:"Octave",   semitones:12 }
];

let intScore = 0, intAnswered = 0, intCorrect = 0;
let intLocked = false;
let intCurrent = null;
let intLast = null;

let intModeIndex = 0;
const INT_MODES = ["Ascending", "Descending", "Harmonic"];

const intScoreEl = document.getElementById("intScore");
const intQnumEl  = document.getElementById("intQnum");
const intAccEl   = document.getElementById("intAcc");
const intModeLabelEl = document.getElementById("intModeLabel");

const intAnswersEl = document.getElementById("intAnswers");
const intFeedbackEl = document.getElementById("intFeedback");

const intPlayBtn = document.getElementById("intPlay");
const intReplayBtn = document.getElementById("intReplay");
const intNextBtn = document.getElementById("intNext");
const intResetBtn = document.getElementById("intReset");
const intModeBtn = document.getElementById("intMode");

let intCtx = null;

function intEnsureAudio(){
  if(intCtx) return;
  intCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function midiToFreq(m){ return 440 * Math.pow(2, (m - 69) / 12); }

function intUpdateStats(){
  intScoreEl.textContent = String(intScore);
  intQnumEl.textContent = String(Math.min(intAnswered + 1, INT_TOTAL_Q));
  const pct = intAnswered === 0 ? 0 : Math.round((intCorrect / intAnswered) * 100);
  intAccEl.textContent = pct + "%";

  const modeName = INT_MODES[intModeIndex];
  intModeLabelEl.textContent = modeName;
  intModeBtn.textContent = "Mode: " + modeName;
}

function intBuildAnswers(){
  intAnswersEl.innerHTML = "";
  const options = shuffle(INTERVALS);
  options.forEach(opt => {
    const b = document.createElement("button");
    b.className = "answer";
    b.textContent = opt.label;
    b.onclick = () => intSelectAnswer(b, opt);
    intAnswersEl.appendChild(b);
  });
}

function intNewQuestion(){
  intLocked = false;
  intFeedbackEl.textContent = "";
  intNextBtn.disabled = true;
  intReplayBtn.disabled = true;

  const rootMidi = 52 + Math.floor(Math.random() * 14);
  const interval = INTERVALS[Math.floor(Math.random() * INTERVALS.length)];
  const mode = INT_MODES[intModeIndex];
  intCurrent = { interval, rootMidi, mode };

  intBuildAnswers();
  [...document.querySelectorAll("#intAnswers .answer")].forEach(b=>{
    b.disabled = false;
    b.classList.remove("correct","wrong");
  });

  intUpdateStats();
}

function intStopLast(){
  try{
    if(intLast){
      intLast.forEach(node => { try{ node.stop?.(); }catch(e){} });
      intLast = null;
    }
  }catch(e){}
}

function intPlayInterval(){
  if(!intCurrent) intNewQuestion();
  intEnsureAudio();
  if(intCtx.state === "suspended") intCtx.resume();

  intStopLast();

  const rootF = midiToFreq(intCurrent.rootMidi);
  const intF  = midiToFreq(intCurrent.rootMidi + intCurrent.interval.semitones);

  const master = intCtx.createGain();
  master.gain.value = 0.0001;
  master.connect(intCtx.destination);

  const now = intCtx.currentTime;

  master.gain.setValueAtTime(0.0001, now);
  master.gain.exponentialRampToValueAtTime(0.2, now + 0.02);
  master.gain.setValueAtTime(0.2, now + 0.9);
  master.gain.exponentialRampToValueAtTime(0.0001, now + 1.05);

  function makeOsc(freq, startT, dur){
    const osc = intCtx.createOscillator();
    osc.type = "sine";
    osc.frequency.setValueAtTime(freq, startT);

    const g = intCtx.createGain();
    g.gain.value = 0.0001;

    osc.connect(g);
    g.connect(master);

    g.gain.setValueAtTime(0.0001, startT);
    g.gain.exponentialRampToValueAtTime(1.0, startT + 0.01);
    g.gain.setValueAtTime(1.0, startT + Math.max(0.05, dur - 0.02));
    g.gain.exponentialRampToValueAtTime(0.0001, startT + dur);

    osc.start(startT);
    osc.stop(startT + dur);
    return osc;
  }

  const mode = intCurrent.mode;

  if(mode === "Ascending"){
    const dur = 0.35;
    const gap = 0.07;
    const a = makeOsc(rootF, now + 0.02, dur);
    const b = makeOsc(intF,  now + 0.02 + dur + gap, dur);
    intLast = [a,b];
  } else if(mode === "Descending"){
    const dur = 0.35;
    const gap = 0.07;
    const a = makeOsc(intF,  now + 0.02, dur);
    const b = makeOsc(rootF, now + 0.02 + dur + gap, dur);
    intLast = [a,b];
  } else {
    const dur = 0.7;
    const a = makeOsc(rootF, now + 0.02, dur);
    const b = makeOsc(intF,  now + 0.02, dur);
    intLast = [a,b];
  }

  intReplayBtn.disabled = false;
}

function intSelectAnswer(btn, opt){
  if(intLocked) return;
  intLocked = true;
  intAnswered++;

  const buttons = [...document.querySelectorAll("#intAnswers .answer")];
  buttons.forEach(b => b.disabled = true);

  const isCorrect = (opt.id === intCurrent.interval.id);

  if(isCorrect){
    intScore++; intCorrect++;
    btn.classList.add("correct");
    intFeedbackEl.innerHTML = `‚úÖ Correct ‚Äî <b>${intCurrent.interval.label}</b>`;
  } else {
    btn.classList.add("wrong");
    intFeedbackEl.innerHTML = `‚ùå Incorrect ‚Äî Correct answer was <b>${intCurrent.interval.label}</b>`;
    buttons.forEach(b=>{ if(b.textContent === intCurrent.interval.label) b.classList.add("correct"); });
  }

  intUpdateStats();
  intNextBtn.disabled = false;
}

intPlayBtn.onclick = () => { if(!intCurrent) intNewQuestion(); intPlayInterval(); };
intReplayBtn.onclick = () => intPlayInterval();
intNextBtn.onclick = () => {
  if(intAnswered >= INT_TOTAL_Q){
    intFeedbackEl.innerHTML = `üéâ Finished! Final Score: <b>${intScore}/${INT_TOTAL_Q}</b>`;
    intNextBtn.disabled = true;
    return;
  }
  intNewQuestion();
};
intResetBtn.onclick = () => { intScore = 0; intAnswered = 0; intCorrect = 0; intUpdateStats(); intNewQuestion(); };
intModeBtn.onclick = () => { intModeIndex = (intModeIndex + 1) % INT_MODES.length; intUpdateStats(); };

/* =====================================================
   SECTION 4: STEREO vs MONO IDENTIFICATION  (bugfix: noise derives from same mono source)
===================================================== */
const ST_TOTAL_Q = 30;
const ST_LOOP_LEN = 4.0;
const ST_NOISE_LEN = 1.9;

const ST_TYPES = [
  { id:"mono",     label:"Mono" },
  { id:"dualmono", label:"Dual Mono" },
  { id:"wide",     label:"Wide Stereo" },
  { id:"hardpan",  label:"Hard Pan" }
];

let stScore = 0, stAnswered = 0, stCorrect = 0;
let stLocked = false;
let stCurrent = null;
let stLastSources = null;

let stCtx = null;
let stNoiseMono = null;

let stTrackBuffer = null;
let stUseTrack = false;

let stLoopStart = 0;
const stLoopSlider = document.getElementById("stLoop");
const stLoopTime = document.getElementById("stLoopTime");
const stPreviewBtn = document.getElementById("stPreview");

const stScoreEl = document.getElementById("stScore");
const stQnumEl  = document.getElementById("stQnum");
const stAccEl   = document.getElementById("stAcc");
const stAnswersEl = document.getElementById("stAnswers");
const stFeedbackEl = document.getElementById("stFeedback");

const stUseNoiseBtn = document.getElementById("stUseNoiseBtn");
const stUseTrackBtn = document.getElementById("stUseTrackBtn");
const stLoadBtn = document.getElementById("stLoadBtn");
const stFile = document.getElementById("stFile");
const stTrackLabel = document.getElementById("stTrackLabel");

function stUpdateStats(){
  stScoreEl.textContent = String(stScore);
  stQnumEl.textContent = String(Math.min(stAnswered + 1, ST_TOTAL_Q));
  const pct = stAnswered === 0 ? 0 : Math.round((stCorrect / stAnswered) * 100);
  stAccEl.textContent = pct + "%";
}

function stEnsureAudio(){
  if(stCtx) return;
  stCtx = new (window.AudioContext || window.webkitAudioContext)();

  const seconds = 2.5;
  const length = Math.floor(stCtx.sampleRate * seconds);

  // one MONO noise bed, then stereo behaviors are created deterministically
  const buffer = stCtx.createBuffer(1, length, stCtx.sampleRate);
  const out = buffer.getChannelData(0);

  let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
  for(let i=0;i<length;i++){
    const white = Math.random()*2 - 1;
    b0 = 0.99886*b0 + white*0.0555179;
    b1 = 0.99332*b1 + white*0.0750759;
    b2 = 0.96900*b2 + white*0.1538520;
    b3 = 0.86650*b3 + white*0.3104856;
    b4 = 0.55000*b4 + white*0.5329522;
    b5 = -0.7616*b5 - white*0.0168980;
    const pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white*0.5362;
    b6 = white*0.115926;
    out[i] = pink * 0.10;
  }
  stNoiseMono = buffer;
}

function stStop(){
  try{
    if(stLastSources){
      stLastSources.forEach(s => { try{ s.stop(); }catch(e){} });
      stLastSources = null;
    }
  }catch(e){}
}

function stBuildAnswers(){
  stAnswersEl.innerHTML = "";
  const options = shuffle(ST_TYPES);
  options.forEach(opt => {
    const b = document.createElement("button");
    b.className = "answer";
    b.textContent = opt.label;
    b.onclick = () => stSelectAnswer(b, opt);
    stAnswersEl.appendChild(b);
  });
}

function stNewQuestion(){
  stLocked = false;
  stFeedbackEl.textContent = "";
  document.getElementById("stNext").disabled = true;
  document.getElementById("stReplay").disabled = true;

  const t = ST_TYPES[Math.floor(Math.random() * ST_TYPES.length)];
  const panSide = (t.id === "hardpan") ? (Math.random() < 0.5 ? "L" : "R") : null;
  stCurrent = { typeId: t.id, panSide };

  stBuildAnswers();
  [...document.querySelectorAll("#stAnswers .answer")].forEach(b=>{
    b.disabled = false;
    b.classList.remove("correct","wrong");
  });

  stUpdateStats();
}

function stSelectAnswer(btn, opt){
  if(stLocked) return;
  stLocked = true;
  stAnswered++;

  const buttons = [...document.querySelectorAll("#stAnswers .answer")];
  buttons.forEach(b => b.disabled = true);

  const correctType = stCurrent.typeId;
  const isCorrect = (opt.id === correctType);

  if(isCorrect){
    stScore++; stCorrect++;
    btn.classList.add("correct");
    stFeedbackEl.innerHTML = `‚úÖ Correct ‚Äî <b>${ST_TYPES.find(x=>x.id===correctType).label}</b>`;
  } else {
    btn.classList.add("wrong");
    const corrLabel = ST_TYPES.find(x=>x.id===correctType).label;
    stFeedbackEl.innerHTML = `‚ùå Incorrect ‚Äî Correct answer was <b>${corrLabel}</b>`;
    buttons.forEach(b=>{ if(b.textContent === corrLabel) b.classList.add("correct"); });
  }

  stUpdateStats();
  document.getElementById("stNext").disabled = false;
}

function stConfigureLoopUI(){
  const hasTrack = !!stTrackBuffer;
  const loopLen = hasTrack ? Math.min(ST_LOOP_LEN, stTrackBuffer.duration) : ST_LOOP_LEN;

  if(hasTrack){
    const maxStart = Math.max(0, stTrackBuffer.duration - loopLen);
    stLoopStart = clamp(stLoopStart, 0, maxStart);

    stLoopSlider.disabled = false;
    stLoopSlider.min = "0";
    stLoopSlider.max = String(maxStart);
    stLoopSlider.step = "0.01";
    stLoopSlider.value = String(stLoopStart);
    stLoopTime.textContent = fmtTime(stLoopStart);
    stPreviewBtn.disabled = !stUseTrack;
  } else {
    stLoopStart = 0;
    stLoopSlider.disabled = true;
    stLoopSlider.min = "0";
    stLoopSlider.max = "0";
    stLoopSlider.value = "0";
    stLoopTime.textContent = "0.00s";
    stPreviewBtn.disabled = true;
  }
}

stLoopSlider.oninput = (e) => {
  stLoopStart = parseFloat(e.target.value || "0");
  stLoopTime.textContent = fmtTime(stLoopStart);
};

function stGetTrackOrNoiseSource(){
  if(stUseTrack && stTrackBuffer){
    const src = stCtx.createBufferSource();
    src.buffer = stTrackBuffer;
    const isStereo = (stTrackBuffer.numberOfChannels && stTrackBuffer.numberOfChannels >= 2);
    return { mode:"track", src, isStereo };
  }
  const src = stCtx.createBufferSource();
  src.buffer = stNoiseMono;
  return { mode:"noise", src, isStereo:false };
}

function stPlay(monitor="STEREO"){
  stEnsureAudio();
  stStop();
  if(!stCurrent) stNewQuestion();
  if(stCtx.state === "suspended") stCtx.resume();

  const now = stCtx.currentTime;
  const startT = now + 0.02;

  const usingTrack = (stUseTrack && stTrackBuffer);
  const segLen = usingTrack ? Math.min(ST_LOOP_LEN, stTrackBuffer.duration) : ST_NOISE_LEN;
  const endT = startT + segLen;

  const master = stCtx.createGain();
  master.gain.value = 0.0001;
  master.connect(stCtx.destination);

  master.gain.setValueAtTime(0.0001, now);
  master.gain.exponentialRampToValueAtTime(0.85, startT + 0.03);
  master.gain.setValueAtTime(0.85, endT - 0.08);
  master.gain.exponentialRampToValueAtTime(0.0001, endT);

  const { mode, src, isStereo } = stGetTrackOrNoiseSource();

  // Build a post-monitor ‚Äúsolo L/R‚Äù stage AFTER all processing (so it never misrepresents the effect)
  const postSplitter = stCtx.createChannelSplitter(2);
  const postMerger = stCtx.createChannelMerger(2);

  const postGL = stCtx.createGain(); postGL.gain.value = (monitor === "R") ? 0.0001 : 1.0;
  const postGR = stCtx.createGain(); postGR.gain.value = (monitor === "L") ? 0.0001 : 1.0;

  postSplitter.connect(postGL, 0);
  postSplitter.connect(postGR, 1);
  postGL.connect(postMerger, 0, 0);
  postGR.connect(postMerger, 0, 1);
  postMerger.connect(master);

  const typeId = stCurrent.typeId;

  const outMerger = stCtx.createChannelMerger(2);
  outMerger.connect(postSplitter);

  function connectMonoToLR(node, lGain, rGain, lDelay=0, rDelay=0){
    const gL = stCtx.createGain(); gL.gain.value = lGain;
    const gR = stCtx.createGain(); gR.gain.value = rGain;

    let leftNode = node;
    let rightNode = node;

    if(lDelay > 0){
      const dL = stCtx.createDelay(0.05);
      dL.delayTime.value = lDelay;
      leftNode.connect(dL);
      leftNode = dL;
    }
    if(rDelay > 0){
      const dR = stCtx.createDelay(0.05);
      dR.delayTime.value = rDelay;
      rightNode.connect(dR);
      rightNode = dR;
    }

    leftNode.connect(gL);
    rightNode.connect(gR);

    gL.connect(outMerger, 0, 0);
    gR.connect(outMerger, 0, 1);
  }

  function connectStereoTrackWithType(trackSrc){
    const split = stCtx.createChannelSplitter(2);
    trackSrc.connect(split);

    const l = stCtx.createGain(); l.gain.value = 1.0;
    const r = stCtx.createGain(); r.gain.value = 1.0;

    split.connect(l, 0);
    split.connect(r, 1);

    if(typeId === "mono"){
      const sum = stCtx.createGain(); sum.gain.value = 0.5;
      l.connect(sum); r.connect(sum);
      connectMonoToLR(sum, 1.0, 1.0);
      return;
    }

    if(typeId === "dualmono"){
      const sum = stCtx.createGain(); sum.gain.value = 0.5;
      l.connect(sum); r.connect(sum);
      connectMonoToLR(sum, 0.92, 1.0, 0, 0.004);
      return;
    }

    if(typeId === "hardpan"){
      const side = stCurrent.panSide || "L";
      const gL = stCtx.createGain(); gL.gain.value = (side === "L") ? 1.0 : 0.0001;
      const gR = stCtx.createGain(); gR.gain.value = (side === "R") ? 1.0 : 0.0001;
      l.connect(gL); r.connect(gR);
      gL.connect(outMerger, 0, 0);
      gR.connect(outMerger, 0, 1);
      return;
    }

    // Wide Stereo: M/S widen on track
    const mid = stCtx.createGain(); mid.gain.value = 0.5;
    const sideL = stCtx.createGain(); sideL.gain.value = 0.5;
    const sideR = stCtx.createGain(); sideR.gain.value = -0.5;

    l.connect(mid); r.connect(mid);
    l.connect(sideL); r.connect(sideR);

    const sideSum = stCtx.createGain(); sideSum.gain.value = 1.0;
    sideL.connect(sideSum);
    sideR.connect(sideSum);

    const sideGain = stCtx.createGain(); sideGain.gain.value = 1.6;
    sideSum.connect(sideGain);

    const sideInv = stCtx.createGain(); sideInv.gain.value = -1.0;
    sideGain.connect(sideInv);

    const outL = stCtx.createGain(); outL.gain.value = 1.0;
    const outR = stCtx.createGain(); outR.gain.value = 1.0;

    mid.connect(outL); sideGain.connect(outL);
    mid.connect(outR); sideInv.connect(outR);

    outL.connect(outMerger, 0, 0);
    outR.connect(outMerger, 0, 1);
  }

  function connectMonoNoiseWithType(noiseSrc){
    if(typeId === "mono"){
      connectMonoToLR(noiseSrc, 1.0, 1.0);
      return;
    }
    if(typeId === "dualmono"){
      connectMonoToLR(noiseSrc, 0.92, 1.0, 0, 0.004);
      return;
    }
    if(typeId === "hardpan"){
      const side = stCurrent.panSide || "L";
      connectMonoToLR(noiseSrc, side === "L" ? 1.0 : 0.0001, side === "R" ? 1.0 : 0.0001);
      return;
    }
    // Wide stereo from mono: small decorrelation on R
    // (this avoids the ‚Äúrandom L/R mismatch‚Äù problem while still being clearly wide)
    connectMonoToLR(noiseSrc, 1.0, 1.0, 0, 0.012);
  }

  if(mode === "noise"){
    connectMonoNoiseWithType(src);

    src.start(startT);
    src.stop(endT + 0.02);
    stLastSources = [src];
  } else {
    if(isStereo) connectStereoTrackWithType(src);
    else connectMonoToLR(src,
      (typeId === "hardpan" && (stCurrent.panSide||"L")==="R") ? 0.0001 : 1.0,
      (typeId === "hardpan" && (stCurrent.panSide||"L")==="L") ? 0.0001 : 1.0,
      (typeId === "wide") ? 0 : 0,
      (typeId === "wide") ? 0.012 : 0
    );

    const loopLen = Math.min(ST_LOOP_LEN, stTrackBuffer.duration);
    const maxStart = Math.max(0, stTrackBuffer.duration - loopLen);
    const offset = clamp(stLoopStart, 0, maxStart);

    src.start(startT, offset, loopLen);
    src.stop(endT + 0.02);

    stLastSources = [src];
  }

  document.getElementById("stReplay").disabled = false;
}

document.getElementById("stPlay").onclick = () => stPlay("STEREO");
document.getElementById("stReplay").onclick = () => stPlay("STEREO");
document.getElementById("stPlayL").onclick = () => stPlay("L");
document.getElementById("stPlayR").onclick = () => stPlay("R");

document.getElementById("stNext").onclick = () => {
  if(stAnswered >= ST_TOTAL_Q){
    stFeedbackEl.innerHTML = `üéâ Finished! Final Score: <b>${stScore}/${ST_TOTAL_Q}</b>`;
    document.getElementById("stNext").disabled = true;
    return;
  }
  stNewQuestion();
};

document.getElementById("stReset").onclick = () => {
  stScore = 0; stAnswered = 0; stCorrect = 0;
  stUpdateStats();
  stNewQuestion();
};

function stRefreshToggleUI(){
  stUseNoiseBtn.classList.toggle("active", !stUseTrack);
  stUseTrackBtn.classList.toggle("active", !!stUseTrack);
  if(stUseTrack && !stTrackBuffer) stTrackLabel.textContent = "No track loaded";
  stConfigureLoopUI();
}

stUseNoiseBtn.onclick = () => { stUseTrack = false; stRefreshToggleUI(); };
stUseTrackBtn.onclick = () => { stUseTrack = true;  stRefreshToggleUI(); };

stLoadBtn.onclick = () => { stEnsureAudio(); stFile.click(); };

stFile.onchange = async (e) => {
  const file = e.target.files?.[0];
  if(!file) return;
  stEnsureAudio();
  try{
    stTrackLabel.textContent = "Loading‚Ä¶";
    const buf = await decodeFileToBuffer(file, stCtx);
    stTrackBuffer = buf;
    stUseTrack = true;
    stTrackLabel.textContent = file.name;
    stLoopStart = 0;
    stRefreshToggleUI();
  }catch(err){
    stTrackBuffer = null;
    stTrackLabel.textContent = "Could not load track";
    stFeedbackEl.innerHTML = `‚ö†Ô∏è Could not decode this file. Try WAV/MP3.`;
    stUseTrack = false;
    stRefreshToggleUI();
  }
};

stPreviewBtn.onclick = () => {
  if(!stTrackBuffer) return;
  stUseTrack = true;
  stRefreshToggleUI();
  stPlay("STEREO");
};

/* =====================================================
   NEW SECTION 5: MID vs SIDE
===================================================== */
/* (unchanged from your paste) */
const MS_TOTAL_Q = 30;
const MS_LOOP_LEN = 4.0;
const MS_TONE_LEN = 2.2;

const MS_TYPES = [
  { id:"mid",  label:"Mid" },
  { id:"side", label:"Side" }
];

let msScore = 0, msAnswered = 0, msCorrect = 0;
let msLocked = false;
let msCurrent = null;
let msLastSources = null;

let msCtx = null;
let msTrackBuffer = null;
let msUseTrack = false;

let msLoopStart = 0;
const msLoopSlider = document.getElementById("msLoop");
const msLoopTime = document.getElementById("msLoopTime");
const msPreviewBtn = document.getElementById("msPreview");

const msScoreEl = document.getElementById("msScore");
const msQnumEl  = document.getElementById("msQnum");
const msAccEl   = document.getElementById("msAcc");
const msAnswersEl = document.getElementById("msAnswers");
const msFeedbackEl = document.getElementById("msFeedback");

const msUseToneBtn = document.getElementById("msUseToneBtn");
const msUseTrackBtn = document.getElementById("msUseTrackBtn");
const msLoadBtn = document.getElementById("msLoadBtn");
const msFile = document.getElementById("msFile");
const msTrackLabel = document.getElementById("msTrackLabel");

function msUpdateStats(){
  msScoreEl.textContent = String(msScore);
  msQnumEl.textContent = String(Math.min(msAnswered + 1, MS_TOTAL_Q));
  const pct = msAnswered === 0 ? 0 : Math.round((msCorrect / msAnswered) * 100);
  msAccEl.textContent = pct + "%";
}

function msEnsureAudio(){
  if(msCtx) return;
  msCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function msStop(){
  try{
    if(msLastSources){
      msLastSources.forEach(s => { try{ s.stop(); }catch(e){} });
      msLastSources = null;
    }
  }catch(e){}
}

function msBuildAnswers(){
  msAnswersEl.innerHTML = "";
  shuffle(MS_TYPES).forEach(opt => {
    const b = document.createElement("button");
    b.className = "answer";
    b.textContent = opt.label;
    b.onclick = () => msSelectAnswer(b, opt);
    msAnswersEl.appendChild(b);
  });
}

function msNewQuestion(){
  msLocked = false;
  msFeedbackEl.textContent = "";
  document.getElementById("msNext").disabled = true;
  document.getElementById("msReplay").disabled = true;

  const t = MS_TYPES[Math.floor(Math.random() * MS_TYPES.length)];
  msCurrent = { typeId: t.id, root: [110, 130.81, 146.83, 164.81, 196][Math.floor(Math.random()*5)] };

  msBuildAnswers();
  [...document.querySelectorAll("#msAnswers .answer")].forEach(b=>{
    b.disabled = false;
    b.classList.remove("correct","wrong");
  });

  msUpdateStats();
}

function msSelectAnswer(btn, opt){
  if(msLocked) return;
  msLocked = true;
  msAnswered++;

  const buttons = [...document.querySelectorAll("#msAnswers .answer")];
  buttons.forEach(b => b.disabled = true);

  const correctType = msCurrent.typeId;
  const isCorrect = (opt.id === correctType);

  if(isCorrect){
    msScore++; msCorrect++;
    btn.classList.add("correct");
    msFeedbackEl.innerHTML = `‚úÖ Correct ‚Äî <b>${MS_TYPES.find(x=>x.id===correctType).label}</b>`;
  } else {
    btn.classList.add("wrong");
    const corrLabel = MS_TYPES.find(x=>x.id===correctType).label;
    msFeedbackEl.innerHTML = `‚ùå Incorrect ‚Äî Correct answer was <b>${corrLabel}</b>`;
    buttons.forEach(b=>{ if(b.textContent === corrLabel) b.classList.add("correct"); });
  }

  msUpdateStats();
  document.getElementById("msNext").disabled = false;
}

function msConfigureLoopUI(){
  const hasTrack = !!msTrackBuffer;
  const loopLen = hasTrack ? Math.min(MS_LOOP_LEN, msTrackBuffer.duration) : MS_LOOP_LEN;

  if(hasTrack){
    const maxStart = Math.max(0, msTrackBuffer.duration - loopLen);
    msLoopStart = clamp(msLoopStart, 0, maxStart);

    msLoopSlider.disabled = false;
    msLoopSlider.min = "0";
    msLoopSlider.max = String(maxStart);
    msLoopSlider.step = "0.01";
    msLoopSlider.value = String(msLoopStart);
    msLoopTime.textContent = fmtTime(msLoopStart);
    msPreviewBtn.disabled = !msUseTrack;
  } else {
    msLoopStart = 0;
    msLoopSlider.disabled = true;
    msLoopSlider.min = "0";
    msLoopSlider.max = "0";
    msLoopSlider.value = "0";
    msLoopTime.textContent = "0.00s";
    msPreviewBtn.disabled = true;
  }
}

msLoopSlider.oninput = (e) => {
  msLoopStart = parseFloat(e.target.value || "0");
  msLoopTime.textContent = fmtTime(msLoopStart);
};

function msRefreshToggleUI(){
  msUseToneBtn.classList.toggle("active", !msUseTrack);
  msUseTrackBtn.classList.toggle("active", !!msUseTrack);
  if(msUseTrack && !msTrackBuffer) msTrackLabel.textContent = "No track loaded";
  msConfigureLoopUI();
}

msUseToneBtn.onclick = () => { msUseTrack = false; msRefreshToggleUI(); };
msUseTrackBtn.onclick = () => { msUseTrack = true;  msRefreshToggleUI(); };
msLoadBtn.onclick = () => { msEnsureAudio(); msFile.click(); };

msFile.onchange = async (e) => {
  const file = e.target.files?.[0];
  if(!file) return;
  msEnsureAudio();
  try{
    msTrackLabel.textContent = "Loading‚Ä¶";
    const buf = await decodeFileToBuffer(file, msCtx);
    msTrackBuffer = buf;
    msUseTrack = true;
    msTrackLabel.textContent = file.name;
    msLoopStart = 0;
    msRefreshToggleUI();
  }catch(err){
    msTrackBuffer = null;
    msTrackLabel.textContent = "Could not load track";
    msFeedbackEl.innerHTML = `‚ö†Ô∏è Could not decode this file. Try WAV/MP3.`;
    msUseTrack = false;
    msRefreshToggleUI();
  }
};

msPreviewBtn.onclick = () => {
  if(!msTrackBuffer) return;
  msUseTrack = true;
  msRefreshToggleUI();
  msPlay();
};

// Build a pseudo-stereo tone bed (so Side has meaning even without a track)
function msMakeStereoTone(rootHz){
  const seconds = 3;
  const sr = msCtx.sampleRate;
  const length = Math.floor(sr * seconds);
  const buf = msCtx.createBuffer(2, length, sr);
  const L = buf.getChannelData(0);
  const R = buf.getChannelData(1);

  const freqs = [rootHz, rootHz*2, rootHz*4, 900, 1800];
  const amps  = [0.45, 0.18, 0.10, 0.10, 0.06];

  const phaseOff = 0.35;

  for(let i=0;i<length;i++){
    const t = i/sr;
    const fadeIn  = Math.min(1, t/0.03);
    const fadeOut = Math.min(1, (seconds-t)/0.03);
    const fade = Math.min(fadeIn, fadeOut);

    let sL=0, sR=0;
    for(let k=0;k<freqs.length;k++){
      const ph = (k%2===0) ? phaseOff : -phaseOff;
      sL += Math.sin(2*Math.PI*freqs[k]*t) * amps[k];
      sR += Math.sin(2*Math.PI*freqs[k]*t + ph) * amps[k];
    }

    L[i] = sL * 0.6 * fade;
    R[i] = sR * 0.6 * fade;
  }

  return buf;
}

// Play either Mid or Side extracted from source
function msPlay(){
  msEnsureAudio();
  msStop();
  if(!msCurrent) msNewQuestion();
  if(msCtx.state === "suspended") msCtx.resume();

  const now = msCtx.currentTime;
  const startT = now + 0.02;

  const usingTrack = (msUseTrack && msTrackBuffer);
  const segLen = usingTrack ? Math.min(MS_LOOP_LEN, msTrackBuffer.duration) : MS_TONE_LEN;
  const endT = startT + segLen;

  const master = msCtx.createGain();
  master.gain.value = 0.0001;
  master.connect(msCtx.destination);

  master.gain.setValueAtTime(0.0001, now);
  master.gain.exponentialRampToValueAtTime(0.85, startT + 0.03);
  master.gain.setValueAtTime(0.85, endT - 0.08);
  master.gain.exponentialRampToValueAtTime(0.0001, endT);

  const src = msCtx.createBufferSource();
  if(usingTrack){
    src.buffer = msTrackBuffer;
  } else {
    src.buffer = msMakeStereoTone(msCurrent.root);
  }

  const isStereo = (src.buffer.numberOfChannels >= 2);
  const splitter = msCtx.createChannelSplitter(2);
  const outMerger = msCtx.createChannelMerger(2);

  src.connect(splitter);

  if(isStereo){
    const gL = msCtx.createGain(); gL.gain.value = 1.0;
    const gR = msCtx.createGain(); gR.gain.value = 1.0;
    splitter.connect(gL, 0);
    splitter.connect(gR, 1);

    const midSum = msCtx.createGain(); midSum.gain.value = 0.5;
    gL.connect(midSum);
    gR.connect(midSum);

    const sideL = msCtx.createGain(); sideL.gain.value = 0.5;
    const sideR = msCtx.createGain(); sideR.gain.value = -0.5;
    gL.connect(sideL);
    gR.connect(sideR);
    const sideSum = msCtx.createGain(); sideSum.gain.value = 1.0;
    sideL.connect(sideSum);
    sideR.connect(sideSum);

    if(msCurrent.typeId === "mid"){
      midSum.connect(outMerger, 0, 0);
      midSum.connect(outMerger, 0, 1);
    } else {
      const inv = msCtx.createGain(); inv.gain.value = -1.0;
      sideSum.connect(inv);

      sideSum.connect(outMerger, 0, 0);
      inv.connect(outMerger, 0, 1);
    }
  } else {
    const mono = msCtx.createGain(); mono.gain.value = 1.0;
    splitter.connect(mono, 0);

    if(msCurrent.typeId === "mid"){
      mono.connect(outMerger, 0, 0);
      mono.connect(outMerger, 0, 1);
    } else {
      const d = msCtx.createDelay(0.05);
      d.delayTime.value = 0.012;
      mono.connect(d);

      mono.connect(outMerger, 0, 0);
      d.connect(outMerger, 0, 1);
    }
  }

  outMerger.connect(master);

  if(usingTrack){
    const loopLen = Math.min(MS_LOOP_LEN, msTrackBuffer.duration);
    const maxStart = Math.max(0, msTrackBuffer.duration - loopLen);
    const offset = clamp(msLoopStart, 0, maxStart);
    src.start(startT, offset, loopLen);
    src.stop(endT + 0.02);
  } else {
    src.start(startT);
    src.stop(endT + 0.02);
  }

  msLastSources = [src];
  document.getElementById("msReplay").disabled = false;
}

document.getElementById("msPlay").onclick = () => msPlay();
document.getElementById("msReplay").onclick = () => msPlay();

document.getElementById("msNext").onclick = () => {
  if(msAnswered >= MS_TOTAL_Q){
    msFeedbackEl.innerHTML = `üéâ Finished! Final Score: <b>${msScore}/${MS_TOTAL_Q}</b>`;
    document.getElementById("msNext").disabled = true;
    return;
  }
  msNewQuestion();
};

document.getElementById("msReset").onclick = () => {
  msScore = 0; msAnswered = 0; msCorrect = 0;
  msUpdateStats();
  msNewQuestion();
};

/* =====================================================
   NEW SECTION 6: PHASE (IN vs OUT)  ‚Äî TONE-BASED
===================================================== */
/* (unchanged from your paste) */
const PH_TOTAL_Q = 30;
const PH_LOOP_LEN = 4.0;
const PH_TONE_LEN = 2.2;

const PH_TYPES = [
  { id:"in",  label:"In Phase" },
  { id:"out", label:"Out of Phase" }
];

let phScore = 0, phAnswered = 0, phCorrect = 0;
let phLocked = false;
let phCurrent = null;
let phLastSources = null;

let phCtx = null;
let phTrackBuffer = null;
let phUseTrack = false;

let phLoopStart = 0;
const phLoopSlider = document.getElementById("phLoop");
const phLoopTime = document.getElementById("phLoopTime");
const phPreviewBtn = document.getElementById("phPreview");

const phScoreEl = document.getElementById("phScore");
const phQnumEl  = document.getElementById("phQnum");
const phAccEl   = document.getElementById("phAcc");
const phAnswersEl = document.getElementById("phAnswers");
const phFeedbackEl = document.getElementById("phFeedback");

const phUseToneBtn = document.getElementById("phUseToneBtn");
const phUseTrackBtn = document.getElementById("phUseTrackBtn");
const phLoadBtn = document.getElementById("phLoadBtn");
const phFile = document.getElementById("phFile");
const phTrackLabel = document.getElementById("phTrackLabel");

function phUpdateStats(){
  phScoreEl.textContent = String(phScore);
  phQnumEl.textContent = String(Math.min(phAnswered + 1, PH_TOTAL_Q));
  const pct = phAnswered === 0 ? 0 : Math.round((phCorrect / phAnswered) * 100);
  phAccEl.textContent = pct + "%";
}

function phEnsureAudio(){
  if(phCtx) return;
  phCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function phStop(){
  try{
    if(phLastSources){
      phLastSources.forEach(s => { try{ s.stop(); }catch(e){} });
      phLastSources = null;
    }
  }catch(e){}
}

function phBuildAnswers(){
  phAnswersEl.innerHTML = "";
  shuffle(PH_TYPES).forEach(opt => {
    const b = document.createElement("button");
    b.className = "answer";
    b.textContent = opt.label;
    b.onclick = () => phSelectAnswer(b, opt);
    phAnswersEl.appendChild(b);
  });
}

function phNewQuestion(){
  phLocked = false;
  phFeedbackEl.textContent = "";
  document.getElementById("phNext").disabled = true;
  document.getElementById("phReplay").disabled = true;

  const t = PH_TYPES[Math.floor(Math.random() * PH_TYPES.length)];

  const roots = [82.41, 98.0, 110.0, 130.81, 146.83, 164.81, 196.0];
  const root = roots[Math.floor(Math.random() * roots.length)];

  phCurrent = { typeId: t.id, rootHz: root };

  phBuildAnswers();
  [...document.querySelectorAll("#phAnswers .answer")].forEach(b=>{
    b.disabled = false;
    b.classList.remove("correct","wrong");
  });

  phUpdateStats();
}

function phSelectAnswer(btn, opt){
  if(phLocked) return;
  phLocked = true;
  phAnswered++;

  const buttons = [...document.querySelectorAll("#phAnswers .answer")];
  buttons.forEach(b => b.disabled = true);

  const correctType = phCurrent.typeId;
  const isCorrect = (opt.id === correctType);

  if(isCorrect){
    phScore++; phCorrect++;
    btn.classList.add("correct");
    phFeedbackEl.innerHTML = `‚úÖ Correct ‚Äî <b>${PH_TYPES.find(x=>x.id===correctType).label}</b>`;
  } else {
    btn.classList.add("wrong");
    const corrLabel = PH_TYPES.find(x=>x.id===correctType).label;
    phFeedbackEl.innerHTML = `‚ùå Incorrect ‚Äî Correct answer was <b>${corrLabel}</b>`;
    buttons.forEach(b=>{ if(b.textContent === corrLabel) b.classList.add("correct"); });
  }

  phUpdateStats();
  document.getElementById("phNext").disabled = false;
}

function phConfigureLoopUI(){
  const hasTrack = !!phTrackBuffer;
  const loopLen = hasTrack ? Math.min(PH_LOOP_LEN, phTrackBuffer.duration) : PH_LOOP_LEN;

  if(hasTrack){
    const maxStart = Math.max(0, phTrackBuffer.duration - loopLen);
    phLoopStart = clamp(phLoopStart, 0, maxStart);

    phLoopSlider.disabled = false;
    phLoopSlider.min = "0";
    phLoopSlider.max = String(maxStart);
    phLoopSlider.step = "0.01";
    phLoopSlider.value = String(phLoopStart);
    phLoopTime.textContent = fmtTime(phLoopStart);
    phPreviewBtn.disabled = !phUseTrack;
  } else {
    phLoopStart = 0;
    phLoopSlider.disabled = true;
    phLoopSlider.min = "0";
    phLoopSlider.max = "0";
    phLoopSlider.value = "0";
    phLoopTime.textContent = "0.00s";
    phPreviewBtn.disabled = true;
  }
}

phLoopSlider.oninput = (e) => {
  phLoopStart = parseFloat(e.target.value || "0");
  phLoopTime.textContent = fmtTime(phLoopStart);
};

function phRefreshToggleUI(){
  phUseToneBtn.classList.toggle("active", !phUseTrack);
  phUseTrackBtn.classList.toggle("active", !!phUseTrack);
  if(phUseTrack && !phTrackBuffer) phTrackLabel.textContent = "No track loaded";
  phConfigureLoopUI();
}

phUseToneBtn.onclick = () => { phUseTrack = false; phRefreshToggleUI(); };
phUseTrackBtn.onclick = () => { phUseTrack = true;  phRefreshToggleUI(); };
phLoadBtn.onclick = () => { phEnsureAudio(); phFile.click(); };

phFile.onchange = async (e) => {
  const file = e.target.files?.[0];
  if(!file) return;
  phEnsureAudio();
  try{
    phTrackLabel.textContent = "Loading‚Ä¶";
    const buf = await decodeFileToBuffer(file, phCtx);
    phTrackBuffer = buf;
    phUseTrack = true;
    phTrackLabel.textContent = file.name;
    phLoopStart = 0;
    phRefreshToggleUI();
  }catch(err){
    phTrackBuffer = null;
    phTrackLabel.textContent = "Could not load track";
    phFeedbackEl.innerHTML = `‚ö†Ô∏è Could not decode this file. Try WAV/MP3.`;
    phUseTrack = false;
    phRefreshToggleUI();
  }
};

phPreviewBtn.onclick = () => {
  if(!phTrackBuffer) return;
  phUseTrack = true;
  phRefreshToggleUI();
  phPlay("STEREO");
};

function phMakeMonoToneBuffer(rootHz){
  const seconds = 3;
  const sr = phCtx.sampleRate;
  const length = Math.floor(sr * seconds);
  const buffer = phCtx.createBuffer(1, length, sr);
  const out = buffer.getChannelData(0);

  const freqs = [rootHz, rootHz*2, rootHz*4, 900, 1800];
  const amps  = [0.52, 0.22, 0.10, 0.10, 0.06];

  const wobbleHz = 0.35;

  for(let i=0;i<length;i++){
    const t = i/sr;
    const fadeIn  = Math.min(1, t/0.03);
    const fadeOut = Math.min(1, (seconds-t)/0.03);
    const fade = Math.min(fadeIn, fadeOut);
    const wobble = 0.85 + 0.15 * Math.sin(2*Math.PI*wobbleHz*t);

    let s = 0;
    for(let k=0;k<freqs.length;k++){
      s += Math.sin(2*Math.PI*freqs[k]*t) * amps[k];
    }

    out[i] = s * 0.65 * wobble * fade;
  }

  return buffer;
}

function phBuildMonitorChain(finalStereoNode, monitor, master){
  if(monitor === "STEREO"){
    finalStereoNode.connect(master);
    return;
  }
  const splitter = phCtx.createChannelSplitter(2);
  finalStereoNode.connect(splitter);
  const monoMerger = phCtx.createChannelMerger(1);
  const chanIndex = (monitor === "L") ? 0 : 1;
  splitter.connect(monoMerger, chanIndex, 0);
  monoMerger.connect(master);
}

function phPlay(monitor="STEREO"){
  phEnsureAudio();
  phStop();
  if(!phCurrent) phNewQuestion();
  if(phCtx.state === "suspended") phCtx.resume();

  const now = phCtx.currentTime;
  const startT = now + 0.02;

  const usingTrack = (phUseTrack && phTrackBuffer);
  const segLen = usingTrack ? Math.min(PH_LOOP_LEN, phTrackBuffer.duration) : PH_TONE_LEN;
  const endT = startT + segLen;

  const master = phCtx.createGain();
  master.gain.value = 0.0001;
  master.connect(phCtx.destination);

  master.gain.setValueAtTime(0.0001, now);
  master.gain.exponentialRampToValueAtTime(0.85, startT + 0.03);
  master.gain.setValueAtTime(0.85, endT - 0.08);
  master.gain.exponentialRampToValueAtTime(0.0001, endT);

  const finalOut = phCtx.createChannelMerger(2);
  phBuildMonitorChain(finalOut, monitor, master);

  const outType = phCurrent.typeId;

  const src = phCtx.createBufferSource();
  if(usingTrack){
    src.buffer = phTrackBuffer;
  } else {
    src.buffer = phMakeMonoToneBuffer(phCurrent.rootHz);
  }

  const isStereo = usingTrack && (phTrackBuffer.numberOfChannels && phTrackBuffer.numberOfChannels >= 2);

  if(isStereo){
    const splitter = phCtx.createChannelSplitter(2);
    src.connect(splitter);

    const L = phCtx.createGain(); L.gain.value = 1.0;
    const R = phCtx.createGain(); R.gain.value = 1.0;
    splitter.connect(L, 0);
    splitter.connect(R, 1);

    if(outType === "out"){
      const invR = phCtx.createGain(); invR.gain.value = -1.0;
      R.connect(invR);
      L.connect(finalOut, 0, 0);
      invR.connect(finalOut, 0, 1);
    } else {
      L.connect(finalOut, 0, 0);
      R.connect(finalOut, 0, 1);
    }
  } else {
    const L = phCtx.createGain(); L.gain.value = 1.0;
    const R = phCtx.createGain(); R.gain.value = 1.0;

    src.connect(L);
    src.connect(R);

    if(outType === "out"){
      const invR = phCtx.createGain(); invR.gain.value = -1.0;
      R.connect(invR);
      L.connect(finalOut, 0, 0);
      invR.connect(finalOut, 0, 1);
    } else {
      L.connect(finalOut, 0, 0);
      R.connect(finalOut, 0, 1);
    }
  }

  if(usingTrack){
    const loopLen = Math.min(PH_LOOP_LEN, phTrackBuffer.duration);
    const maxStart = Math.max(0, phTrackBuffer.duration - loopLen);
    const offset = clamp(phLoopStart, 0, maxStart);
    src.start(startT, offset, loopLen);
    src.stop(endT + 0.02);
  } else {
    src.start(startT);
    src.stop(endT + 0.02);
  }

  phLastSources = [src];
  document.getElementById("phReplay").disabled = false;
}

document.getElementById("phPlay").onclick = () => phPlay("STEREO");
document.getElementById("phReplay").onclick = () => phPlay("STEREO");
document.getElementById("phPlayL").onclick = () => phPlay("L");
document.getElementById("phPlayR").onclick = () => phPlay("R");

document.getElementById("phNext").onclick = () => {
  if(phAnswered >= PH_TOTAL_Q){
    phFeedbackEl.innerHTML = `üéâ Finished! Final Score: <b>${phScore}/${PH_TOTAL_Q}</b>`;
    document.getElementById("phNext").disabled = true;
    return;
  }
  phNewQuestion();
};

document.getElementById("phReset").onclick = () => {
  phScore = 0; phAnswered = 0; phCorrect = 0;
  phUpdateStats();
  phNewQuestion();
};

/* =====================================================
   NEW SECTION 7: FEEDBACK TRAINER (Graphic EQ)
===================================================== */
const FB_TOTAL_Q = 30;

const FB_BANDS = [
  { id:"31",  label:"31",  freq:31.5 },
  { id:"63",  label:"63",  freq:63 },
  { id:"125", label:"125", freq:125 },
  { id:"250", label:"250", freq:250 },
  { id:"500", label:"500", freq:500 },
  { id:"1k",  label:"1k",  freq:1000 },
  { id:"2k",  label:"2k",  freq:2000 },
  { id:"4k",  label:"4k",  freq:4000 },
  { id:"8k",  label:"8k",  freq:8000 },
  { id:"16k", label:"16k", freq:16000 }
];

let fbScore = 0, fbAnswered = 0, fbCorrect = 0;
let fbLocked = false;
let fbCurrent = null;

let fbCtx = null;
let fbWhiteNoise = null;
let fbLastNodes = [];

let fbModeIndex = 0;
const FB_MODES = ["Noise + Ring", "Tone Only"];

const fbScoreEl = document.getElementById("fbScore");
const fbQnumEl  = document.getElementById("fbQnum");
const fbAccEl   = document.getElementById("fbAcc");
const fbEqEl    = document.getElementById("fbEq");
const fbFeedbackEl = document.getElementById("fbFeedback");
const fbModeBtn = document.getElementById("fbMode");
const fbModeLabel = document.getElementById("fbModeLabel");

function fbUpdateStats(){
  fbScoreEl.textContent = String(fbScore);
  fbQnumEl.textContent = String(Math.min(fbAnswered + 1, FB_TOTAL_Q));
  const pct = fbAnswered === 0 ? 0 : Math.round((fbCorrect / fbAnswered) * 100);
  fbAccEl.textContent = pct + "%";
  fbModeLabel.textContent = FB_MODES[fbModeIndex];
  fbModeBtn.textContent = "Mode: " + FB_MODES[fbModeIndex];
}

function fbEnsureAudio(){
  if(fbCtx) return;
  fbCtx = new (window.AudioContext || window.webkitAudioContext)();

  // very bright WHITE noise so resonance is super obvious
  const seconds = 3;
  const length = Math.floor(fbCtx.sampleRate * seconds);
  const buffer = fbCtx.createBuffer(1, length, fbCtx.sampleRate);
  const out = buffer.getChannelData(0);

  for(let i=0;i<length;i++){
    out[i] = (Math.random()*2 - 1) * 0.18;
  }
  fbWhiteNoise = buffer;
}

function fbStop(){
  try{
    fbLastNodes.forEach(n => { try{ n.stop?.(); }catch(e){} });
  }catch(e){}
  fbLastNodes = [];
}

function fbBuildEq(){
  fbEqEl.innerHTML = "";
  FB_BANDS.forEach(band => {
    const btn = document.createElement("button");
    btn.className = "geqBand";
    btn.setAttribute("data-id", band.id);

    const track = document.createElement("div");
    track.className = "geqTrack";
    const knob = document.createElement("div");
    knob.className = "geqKnob";
    track.appendChild(knob);

    const lab = document.createElement("div");
    lab.className = "geqLabel";
    lab.textContent = band.label;

    btn.appendChild(track);
    btn.appendChild(lab);

    btn.onclick = () => fbSelectBand(btn, band);
    fbEqEl.appendChild(btn);
  });
}

function fbNewQuestion(){
  fbLocked = false;
  fbFeedbackEl.textContent = "";
  document.getElementById("fbNext").disabled = true;
  document.getElementById("fbReplay").disabled = true;

  const band = FB_BANDS[Math.floor(Math.random() * FB_BANDS.length)];
  fbCurrent = { band };

  [...document.querySelectorAll("#fbEq .geqBand")].forEach(b=>{
    b.disabled = false;
    b.classList.remove("correct","wrong");
  });

  fbUpdateStats();
}

function fbSelectBand(btn, band){
  if(fbLocked) return;
  fbLocked = true;
  fbAnswered++;

  const correctId = fbCurrent.band.id;
  const isCorrect = (band.id === correctId);

  const buttons = [...document.querySelectorAll("#fbEq .geqBand")];
  buttons.forEach(b => b.disabled = true);

  buttons.forEach(b=>{
    if(b.getAttribute("data-id") === correctId) b.classList.add("correct");
  });

  if(isCorrect){
    fbScore++; fbCorrect++;
    btn.classList.add("correct");
    fbFeedbackEl.innerHTML = `‚úÖ Correct ‚Äî cut <b>${fbCurrent.band.label}</b>`;
  } else {
    btn.classList.add("wrong");
    fbFeedbackEl.innerHTML = `‚ùå Incorrect ‚Äî best cut was <b>${fbCurrent.band.label}</b>`;
  }

  fbUpdateStats();
  document.getElementById("fbNext").disabled = false;
}

function fbPlay(){
  fbEnsureAudio();
  fbStop();
  if(!fbCurrent) fbNewQuestion();
  if(fbCtx.state === "suspended") fbCtx.resume();

  const now = fbCtx.currentTime;
  const startT = now + 0.02;
  const dur = 2.2;
  const endT = startT + dur;

  const master = fbCtx.createGain();
  master.gain.value = 0.0001;
  master.connect(fbCtx.destination);

  master.gain.setValueAtTime(0.0001, now);
  master.gain.exponentialRampToValueAtTime(0.95, startT + 0.03);
  master.gain.setValueAtTime(0.95, endT - 0.08);
  master.gain.exponentialRampToValueAtTime(0.0001, endT);

  const mode = FB_MODES[fbModeIndex];
  const f = fbCurrent.band.freq;

  if(mode === "Tone Only"){
    const osc = fbCtx.createOscillator();
    osc.type = "sine";
    osc.frequency.setValueAtTime(f, startT);

    const g = fbCtx.createGain();
    g.gain.value = 0.0001;

    osc.connect(g);
    g.connect(master);

    g.gain.setValueAtTime(0.0001, startT);
    g.gain.exponentialRampToValueAtTime(1.0, startT + 0.02);
    g.gain.setValueAtTime(1.0, endT - 0.07);
    g.gain.exponentialRampToValueAtTime(0.0001, endT);

    osc.start(startT);
    osc.stop(endT + 0.02);

    fbLastNodes = [osc];
  } else {
    const src = fbCtx.createBufferSource();
    src.buffer = fbWhiteNoise;

    const peak = fbCtx.createBiquadFilter();
    peak.type = "peaking";
    peak.frequency.value = f;

    peak.Q.value = 18;
    peak.gain.value = 26;

    const hpf = fbCtx.createBiquadFilter();
    hpf.type = "highpass";
    hpf.frequency.value = 35;
    hpf.Q.value = 0.7;

    src.connect(hpf);
    hpf.connect(peak);
    peak.connect(master);

    src.start(startT, 0, dur);
    src.stop(endT + 0.02);

    fbLastNodes = [src];
  }

  document.getElementById("fbReplay").disabled = false;
}

document.getElementById("fbPlay").onclick = () => fbPlay();
document.getElementById("fbReplay").onclick = () => fbPlay();

document.getElementById("fbNext").onclick = () => {
  if(fbAnswered >= FB_TOTAL_Q){
    fbFeedbackEl.innerHTML = `üéâ Finished! Final Score: <b>${fbScore}/${FB_TOTAL_Q}</b>`;
    document.getElementById("fbNext").disabled = true;
    return;
  }
  fbNewQuestion();
};

document.getElementById("fbReset").onclick = () => {
  fbScore = 0; fbAnswered = 0; fbCorrect = 0;
  fbUpdateStats();
  fbNewQuestion();
};

fbModeBtn.onclick = () => {
  fbModeIndex = (fbModeIndex + 1) % FB_MODES.length;
  fbUpdateStats();
};

fbBuildEq();
fbUpdateStats();
fbNewQuestion();

/* =====================================================
   START / PREP
===================================================== */
showView("menu");
newQuestion();

eqBuildAnswerButtons();
eqUpdateStats();
eqNewQuestion();
eqRefreshToggleUI();

intUpdateStats();
intNewQuestion();

stUpdateStats();
stNewQuestion();
stRefreshToggleUI();

msUpdateStats();
msNewQuestion();
msRefreshToggleUI();

phUpdateStats();
phNewQuestion();
phRefreshToggleUI();
</script>
</body>
</html>
```
