```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Ear Training Hub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root{
      --bg:#0e1118;
      --card:#161b2a;
      --card2:#1e2440;
      --muted:#9aa4b2;
      --text:#e8ecf2;
      --btn:#273050;
      --btnHover:#313c63;
      --good:#1f4d3a;
      --bad:#4d1f2a;
      --radius:16px;
      --shadow:0 20px 40px rgba(0,0,0,.4);
      --font: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:var(--font);
      display:flex;
      justify-content:center;
      min-height:100vh;
      padding:24px;
    }
    .app{
      width:900px;
      max-width:100%;
    }
    .card{
      background:var(--card);
      border-radius:var(--radius);
      padding:20px;
      box-shadow:var(--shadow);
    }
    h1{ margin:0 0 6px; font-size:22px; }
    .sub{ margin:0 0 16px; color:var(--muted); font-size:14px; }

    .hidden{ display:none !important; }

    /* Menu */
    .menuGrid{
      display:grid;
      grid-template-columns:repeat(3, 1fr);
      gap:12px;
      margin-top:12px;
    }
    @media(max-width:800px){
      .menuGrid{ grid-template-columns:1fr; }
    }
    .menuBtn{
      text-align:left;
      border:none;
      background:var(--card2);
      color:var(--text);
      padding:16px;
      border-radius:14px;
      cursor:pointer;
      transition:background .12s ease, transform .06s ease;
      box-shadow:0 8px 18px rgba(0,0,0,.25);
    }
    .menuBtn:hover{ background:#252d52; }
    .menuBtn:active{ transform:scale(.99); }
    .menuTitle{ font-weight:800; font-size:16px; margin-bottom:6px; }
    .menuDesc{ color:var(--muted); font-size:13px; line-height:1.35; }

    /* Shared UI */
    .top{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      flex-wrap:wrap;
      gap:10px;
    }
    .stats{
      display:flex;
      gap:10px;
      font-size:13px;
      color:var(--muted);
      flex-wrap:wrap;
      align-items:center;
    }
    .pill{
      background:#222840;
      padding:6px 10px;
      border-radius:999px;
    }
    .controls{
      margin-top:14px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    button.action{
      background:var(--btn);
      border:none;
      color:#fff;
      padding:10px 14px;
      border-radius:10px;
      cursor:pointer;
      font-weight:700;
    }
    button.action:hover{ background:var(--btnHover); }
    button.action:disabled{ opacity:.45; cursor:not-allowed; }

    .answers{
      margin-top:18px;
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:10px;
    }
    @media(max-width:600px){
      .answers{ grid-template-columns:1fr; }
    }
    .answer{
      background:var(--card2);
      border-radius:10px;
      padding:12px;
      border:none;
      color:var(--text);
      cursor:pointer;
      font-weight:700;
      text-align:left;
    }
    .answer:hover{ background:#252d52; }
    .answer:disabled{ opacity:.9; cursor:not-allowed; }
    .answer.correct{ background:var(--good) !important; }
    .answer.wrong{ background:var(--bad) !important; }

    .feedback{
      margin-top:14px;
      min-height:22px;
      font-size:14px;
      color:#cfd6e4;
    }

    .backRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-top:14px;
      border-top:1px solid rgba(255,255,255,.08);
      padding-top:14px;
    }
    .smallNote{ color:var(--muted); font-size:12px; line-height:1.35; }

    /* Section 3 extras */
    .twoCol{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media(max-width:700px){
      .twoCol{ grid-template-columns:1fr; }
    }
    .panel{
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      padding:12px;
    }
    .panelTitle{
      font-weight:800;
      margin-bottom:6px;
      font-size:13px;
      color:#d7deee;
    }
    .chips{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .chip{
      background:#222840;
      border-radius:999px;
      padding:6px 10px;
      font-size:12px;
      color:#cfd6e4;
    }

    /* Section 3: two clear columns for Band vs Boost/Cut */
    .eqAnswerGrid{
      display:grid;
      grid-template-columns: 2fr 1fr;
      gap:12px;
      margin-top:18px;
    }
    @media(max-width:700px){
      .eqAnswerGrid{ grid-template-columns:1fr; }
    }
  </style>
</head>

<body>
<div class="app">

  <!-- =========================
       FRONT PAGE / MENU
  ========================== -->
  <div class="card" id="view-menu">
    <h1>Ear Training Hub</h1>
    <p class="sub">Choose a training section.</p>

    <div class="menuGrid">
      <button class="menuBtn" id="go-frequency">
        <div class="menuTitle">Frequency Training</div>
        <div class="menuDesc">Identify pure tones (e.g., 250 Hz, 1 kHz, 5 kHz). Multiple choice with scoring.</div>
      </button>

      <button class="menuBtn" id="go-interval">
        <div class="menuTitle">Interval Training</div>
        <div class="menuDesc">Recognize intervals by ear (Semitone, Third, Fifth, Octave).</div>
      </button>

      <button class="menuBtn" id="go-section3">
        <div class="menuTitle">EQ Move Training</div>
        <div class="menuDesc">Compare Original vs Processed pink noise and identify the band + whether it was boosted or cut.</div>
      </button>

      <button class="menuBtn" id="go-stereo">
        <div class="menuTitle">Stereo vs Mono Identification</div>
        <div class="menuDesc">Identify Mono, Dual Mono, Wide Stereo, or Hard Pan from the playback.</div>
      </button>
    </div>

    <div class="backRow">
      <div class="smallNote">
        Folder setup: <b>index.html</b> + <b>audio/</b> (your mp3s).
      </div>
    </div>
  </div>

  <!-- =========================
       FREQUENCY TRAINING
  ========================== -->
  <div class="card hidden" id="view-frequency">
    <div class="top">
      <div>
        <h1>Frequency Training</h1>
        <p class="sub">Press Play, then choose the correct frequency.</p>
      </div>
      <div class="stats">
        <div class="pill">Score: <span id="score">0</span></div>
        <div class="pill">Question: <span id="qnum">1</span>/30</div>
        <div class="pill">Accuracy: <span id="acc">0%</span></div>
      </div>
    </div>

    <div class="controls">
      <button class="action" id="play">‚ñ∂ Play</button>
      <button class="action" id="replay" disabled>‚Üª Replay</button>
      <button class="action" id="next" disabled>Next ‚Üí</button>
      <button class="action" id="reset" style="margin-left:auto;">Reset</button>
    </div>

    <div class="answers" id="answers"></div>
    <div class="feedback" id="feedback"></div>

    <div class="backRow">
      <button class="action" id="backFromFrequency">‚Üê Back to Menu</button>
      <div class="smallNote">
        Tip: let students replay before answering. We can add difficulty modes next.
      </div>
    </div>
  </div>

  <!-- =========================
       INTERVAL TRAINING
  ========================== -->
  <div class="card hidden" id="view-interval">
    <div class="top">
      <div>
        <h1>Interval Training</h1>
        <p class="sub">Press Play, then identify the interval (Semitone, Third, Fifth, Octave).</p>
      </div>
      <div class="stats">
        <div class="pill">Score: <span id="intScore">0</span></div>
        <div class="pill">Question: <span id="intQnum">1</span>/30</div>
        <div class="pill">Accuracy: <span id="intAcc">0%</span></div>
        <div class="pill">Mode: <span id="intModeLabel">Ascending</span></div>
      </div>
    </div>

    <div class="controls">
      <button class="action" id="intPlay">‚ñ∂ Play</button>
      <button class="action" id="intReplay" disabled>‚Üª Replay</button>
      <button class="action" id="intNext" disabled>Next ‚Üí</button>

      <button class="action" id="intMode" style="margin-left:auto;">Mode: Ascending</button>
      <button class="action" id="intReset">Reset</button>
    </div>

    <div class="answers" id="intAnswers"></div>
    <div class="feedback" id="intFeedback"></div>

    <div class="backRow">
      <button class="action" id="backFromInterval">‚Üê Back to Menu</button>
      <div class="smallNote">
        Tip: Start with Ascending. Later we can add Descending-only tests or reference tones.
      </div>
    </div>
  </div>

  <!-- =========================
       SECTION 3: EQ MOVE TRAINING
  ========================== -->
  <div class="card hidden" id="view-section3">
    <div class="top">
      <div>
        <h1>EQ Move Training</h1>
        <p class="sub">Compare <b>Original</b> vs <b>Processed</b>, then pick the <b>band</b> and whether it was <b>boosted</b> or <b>cut</b>.</p>
      </div>
      <div class="stats">
        <div class="pill">Score: <span id="eqScore">0</span></div>
        <div class="pill">Question: <span id="eqQnum">1</span>/30</div>
        <div class="pill">Accuracy: <span id="eqAcc">0%</span></div>
      </div>
    </div>

    <div class="twoCol">
      <div class="panel">
        <div class="panelTitle">Bands (broad mix zones)</div>
        <div class="chips">
          <div class="chip">Sub (20‚Äì60)</div>
          <div class="chip">Bass (60‚Äì200)</div>
          <div class="chip">Low-Mid (200‚Äì600)</div>
          <div class="chip">Mid (600‚Äì2k)</div>
          <div class="chip">High-Mid (2‚Äì6k)</div>
          <div class="chip">Air (8k+)</div>
        </div>
      </div>

      <div class="panel">
        <div class="panelTitle">How it works</div>
        <div class="smallNote">
          Each question applies ONE EQ move. Use <b>Play A</b> for Original and <b>Play B</b> for Processed.
          (You can still use ‚ñ∂ Play for an A‚ÜíB sequence.)
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="action" id="eqPlay">‚ñ∂ Play</button>
      <button class="action" id="eqReplay" disabled>‚Üª Replay</button>
      <button class="action" id="eqNext" disabled>Next ‚Üí</button>

      <button class="action" id="eqPlayA" style="margin-left:auto;">Play A</button>
      <button class="action" id="eqPlayB">Play B</button>

      <button class="action" id="eqReset">Reset</button>
    </div>

    <div class="eqAnswerGrid">
      <div>
        <div class="panelTitle" style="margin:6px 0 8px;">Pick the band</div>
        <div class="answers" id="eqBandAnswers"></div>
      </div>
      <div>
        <div class="panelTitle" style="margin:6px 0 8px;">Boost or Cut?</div>
        <div class="answers" id="eqMoveAnswers"></div>
      </div>
    </div>

    <div class="feedback" id="eqFeedback"></div>

    <div class="backRow">
      <button class="action" id="backFromSection3">‚Üê Back to Menu</button>
      <div class="smallNote">
        Tip: If students struggle, increase the gain (¬±9 dB) or reduce to 4 bands.
      </div>
    </div>
  </div>

  <!-- =========================
       SECTION 4: STEREO vs MONO IDENTIFICATION
  ========================== -->
  <div class="card hidden" id="view-stereo">
    <div class="top">
      <div>
        <h1>Stereo vs Mono Identification</h1>
        <p class="sub">Press Play, then identify the playback type: <b>Mono</b>, <b>Dual Mono</b>, <b>Wide Stereo</b>, or <b>Hard Pan</b>.</p>
      </div>
      <div class="stats">
        <div class="pill">Score: <span id="stScore">0</span></div>
        <div class="pill">Question: <span id="stQnum">1</span>/30</div>
        <div class="pill">Accuracy: <span id="stAcc">0%</span></div>
      </div>
    </div>

    <div class="twoCol">
      <div class="panel">
        <div class="panelTitle">What to listen for</div>
        <div class="smallNote">
          <ul style="margin:8px 0 0 18px; color:var(--muted);">
            <li><b>Mono:</b> centered, same in both ears.</li>
            <li><b>Dual Mono:</b> mostly centered, but subtle L/R differences (tiny delay/level).</li>
            <li><b>Wide Stereo:</b> noticeably wide; center feels ‚Äúspread‚Äù.</li>
            <li><b>Hard Pan:</b> mostly one side (left or right).</li>
          </ul>
        </div>
      </div>
      <div class="panel">
        <div class="panelTitle">Quick compare tools</div>
        <div class="smallNote">
          Use <b>Play L</b> / <b>Play R</b> to check what‚Äôs happening on each side without waiting.
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="action" id="stPlay">‚ñ∂ Play</button>
      <button class="action" id="stReplay" disabled>‚Üª Replay</button>
      <button class="action" id="stNext" disabled>Next ‚Üí</button>

      <button class="action" id="stPlayL" style="margin-left:auto;">Play L</button>
      <button class="action" id="stPlayR">Play R</button>

      <button class="action" id="stReset">Reset</button>
    </div>

    <div class="answers" id="stAnswers"></div>
    <div class="feedback" id="stFeedback"></div>

    <div class="backRow">
      <button class="action" id="backFromStereo">‚Üê Back to Menu</button>
      <div class="smallNote">
        Tip: This gets easier on headphones. We can add a ‚Äúdifficulty‚Äù toggle later (more subtle widening).
      </div>
    </div>
  </div>

</div>

<audio id="player"></audio>

<script>
/* =====================================================
   SIMPLE VIEW ROUTER
===================================================== */
const views = {
  menu: document.getElementById("view-menu"),
  frequency: document.getElementById("view-frequency"),
  interval: document.getElementById("view-interval"),
  section3: document.getElementById("view-section3"),
  stereo: document.getElementById("view-stereo")
};

function showView(name){
  Object.values(views).forEach(v => v.classList.add("hidden"));
  views[name].classList.remove("hidden");
}

/* Menu buttons */
document.getElementById("go-frequency").onclick = () => showView("frequency");
document.getElementById("go-interval").onclick = () => showView("interval");
document.getElementById("go-section3").onclick = () => showView("section3");
document.getElementById("go-stereo").onclick = () => showView("stereo");

/* Back buttons */
document.getElementById("backFromFrequency").onclick = () => showView("menu");
document.getElementById("backFromInterval").onclick = () => showView("menu");
document.getElementById("backFromSection3").onclick = () => showView("menu");
document.getElementById("backFromStereo").onclick = () => showView("menu");

/* =====================================================
   FREQUENCY TRAINER
===================================================== */

/* Your mapped files (no renaming needed) */
const FILES = [
  { label:"80 Hz", file:"audio/1..mp3" },
  { label:"100 Hz", file:"audio/2_.mp3" },
  { label:"125 Hz", file:"audio/3..mp3" },
  { label:"250 Hz", file:"audio/4..mp3" },
  { label:"315 Hz", file:"audio/5..mp3" },
  { label:"400 Hz", file:"audio/6..mp3" },
  { label:"500 Hz", file:"audio/7_.mp3" },
  { label:"630 Hz", file:"audio/8..mp3" },
  { label:"800 Hz", file:"audio/9..mp3" },
  { label:"1 kHz", file:"audio/10_.mp3" },
  { label:"2 kHz", file:"audio/11_.mp3" },
  { label:"2.5 kHz", file:"audio/12..mp3" },
  { label:"3.15 kHz", file:"audio/13..mp3" },
  { label:"4 kHz", file:"audio/14..mp3" },
  { label:"5 kHz", file:"audio/15_.mp3" },
  { label:"6.3 kHz", file:"audio/16..mp3" },
  { label:"8 kHz", file:"audio/17..mp3" },
  { label:"10 kHz", file:"audio/18_.mp3" },
  { label:"12 kHz", file:"audio/19_.mp3" },
  { label:"14 kHz", file:"audio/20..mp3" },
  { label:"1 kHz", file:"audio/21_.mp3" },
  { label:"250 Hz", file:"audio/22..mp3" },
  { label:"500 Hz", file:"audio/23_.mp3" },
  { label:"2.15 kHz", file:"audio/24..mp3" },
  { label:"5 kHz", file:"audio/25_.mp3" },
  { label:"10 kHz", file:"audio/26_.mp3" },
  { label:"630 Hz", file:"audio/27..mp3" },
  { label:"125 Hz", file:"audio/28..mp3" },
  { label:"60 Hz", file:"audio/29_.mp3" },
  { label:"10 kHz", file:"audio/30_.mp3" }
];

const ANSWERS_PER_Q = 5;
let pool = [];
let current = null;
let locked = false;

let score = 0;
let answered = 0;
let correct = 0;

const player = document.getElementById("player");
const answersEl = document.getElementById("answers");
const feedbackEl = document.getElementById("feedback");

const scoreEl = document.getElementById("score");
const qnumEl = document.getElementById("qnum");
const accEl = document.getElementById("acc");

function shuffle(a){
  return a.slice().sort(() => Math.random() - 0.5);
}

function refillPool(){
  if(pool.length === 0) pool = shuffle(FILES);
}

function updateStats(){
  scoreEl.textContent = String(score);
  qnumEl.textContent = String(Math.min(answered + 1, FILES.length));
  const pct = answered === 0 ? 0 : Math.round((correct/answered)*100);
  accEl.textContent = pct + "%";
}

function newQuestion(){
  locked = false;
  feedbackEl.textContent = "";
  document.getElementById("next").disabled = true;
  document.getElementById("replay").disabled = true;

  refillPool();
  current = pool.pop();

  const decoys = shuffle(FILES.filter(f => f !== current)).slice(0, ANSWERS_PER_Q - 1);
  const options = shuffle([current, ...decoys]);

  answersEl.innerHTML = "";
  options.forEach(item => {
    const b = document.createElement("button");
    b.className = "answer";
    b.textContent = item.label;
    b.onclick = () => selectAnswer(b, item);
    answersEl.appendChild(b);
  });

  updateStats();
}

function selectAnswer(btn, item){
  if(locked) return;
  locked = true;
  answered++;

  const buttons = document.querySelectorAll("#answers .answer");
  buttons.forEach(b => b.disabled = true);

  if(item === current){
    score++; correct++;
    btn.classList.add("correct");
    feedbackEl.innerHTML = `‚úÖ Correct ‚Äî <b>${current.label}</b>`;
  } else {
    btn.classList.add("wrong");
    feedbackEl.innerHTML = `‚ùå Incorrect ‚Äî Correct answer was <b>${current.label}</b>`;
    buttons.forEach(b => {
      if(b.textContent === current.label) b.classList.add("correct");
    });
  }

  updateStats();
  document.getElementById("next").disabled = false;
}

/* Controls */
document.getElementById("play").onclick = () => {
  if(!current) newQuestion();
  player.src = current.file;
  player.play();
  document.getElementById("replay").disabled = false;
};

document.getElementById("replay").onclick = () => {
  player.currentTime = 0;
  player.play();
};

document.getElementById("next").onclick = () => {
  if(answered >= FILES.length){
    feedbackEl.innerHTML = `üéâ Finished! Final Score: <b>${score}/${FILES.length}</b>`;
    document.getElementById("next").disabled = true;
    return;
  }
  newQuestion();
};

document.getElementById("reset").onclick = () => {
  score = 0; answered = 0; correct = 0;
  pool = [];
  updateStats();
  newQuestion();
};

/* =====================================================
   SECTION 3: EQ MOVE TRAINING (Pink noise + EQ)
===================================================== */

const EQ_TOTAL_Q = 30;

/* Broad ‚Äúmix zones‚Äù (keep it teachable) */
const EQ_BANDS = [
  { id:"sub",     label:"Sub (20‚Äì60 Hz)",     type:"lowshelf",  freq:45,    q:0.7 },
  { id:"bass",    label:"Bass (60‚Äì200 Hz)",   type:"peaking",   freq:110,   q:1.0 },
  { id:"lowmid",  label:"Low-Mid (200‚Äì600)",  type:"peaking",   freq:350,   q:1.1 },
  { id:"mid",     label:"Mid (600‚Äì2k)",       type:"peaking",   freq:1200,  q:1.0 },
  { id:"highmid", label:"High-Mid (2‚Äì6k)",    type:"peaking",   freq:3500,  q:1.0 },
  { id:"air",     label:"Air (8k+)",          type:"highshelf", freq:11000, q:0.7 }
];

let eqScore = 0, eqAnswered = 0, eqCorrect = 0;
let eqLocked = false;

let eqCtx = null;
let eqNoiseBuffer = null;
let eqCurrent = null;     // { band, move } move = "boost"|"cut"
let eqBandGuess = null;
let eqMoveGuess = null;
let eqLastSource = null;

const eqScoreEl = document.getElementById("eqScore");
const eqQnumEl  = document.getElementById("eqQnum");
const eqAccEl   = document.getElementById("eqAcc");
const eqFeedbackEl = document.getElementById("eqFeedback");

const eqBandAnswersEl = document.getElementById("eqBandAnswers");
const eqMoveAnswersEl = document.getElementById("eqMoveAnswers");

const eqPlayABtn = document.getElementById("eqPlayA");
const eqPlayBBtn = document.getElementById("eqPlayB");

function eqUpdateStats(){
  eqScoreEl.textContent = String(eqScore);
  eqQnumEl.textContent = String(Math.min(eqAnswered + 1, EQ_TOTAL_Q));
  const pct = eqAnswered === 0 ? 0 : Math.round((eqCorrect/eqAnswered)*100);
  eqAccEl.textContent = pct + "%";
}

function ensureAudio(){
  if(eqCtx) return;
  eqCtx = new (window.AudioContext || window.webkitAudioContext)();

  // Build a reusable "pink-ish" noise buffer (3s) once
  const seconds = 3;
  const length = Math.floor(eqCtx.sampleRate * seconds);
  const buffer = eqCtx.createBuffer(1, length, eqCtx.sampleRate);
  const out = buffer.getChannelData(0);

  // Simple filtered pink noise approximation (Kellet-ish)
  let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
  for(let i=0;i<length;i++){
    const white = Math.random()*2 - 1;
    b0 = 0.99886*b0 + white*0.0555179;
    b1 = 0.99332*b1 + white*0.0750759;
    b2 = 0.96900*b2 + white*0.1538520;
    b3 = 0.86650*b3 + white*0.3104856;
    b4 = 0.55000*b4 + white*0.5329522;
    b5 = -0.7616*b5 - white*0.0168980;
    const pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white*0.5362;
    b6 = white*0.115926;
    out[i] = pink * 0.11; // trim level a bit
  }

  eqNoiseBuffer = buffer;
}

function eqStopPlayback(){
  try{
    if(eqLastSource){
      eqLastSource.stop();
      eqLastSource.disconnect();
      eqLastSource = null;
    }
  }catch(e){}
}

function eqBuildAnswerButtons(){
  eqBandAnswersEl.innerHTML = "";
  EQ_BANDS.forEach(band => {
    const btn = document.createElement("button");
    btn.className = "answer";
    btn.textContent = band.label;
    btn.onclick = () => eqPickBand(btn, band);
    eqBandAnswersEl.appendChild(btn);
  });

  eqMoveAnswersEl.innerHTML = "";
  ["Boost", "Cut"].forEach(txt => {
    const btn = document.createElement("button");
    btn.className = "answer";
    btn.textContent = txt;
    btn.onclick = () => eqPickMove(btn, txt.toLowerCase());
    eqMoveAnswersEl.appendChild(btn);
  });
}

function eqNewQuestion(){
  eqLocked = false;
  eqBandGuess = null;
  eqMoveGuess = null;
  eqFeedbackEl.textContent = "";
  document.getElementById("eqNext").disabled = true;
  document.getElementById("eqReplay").disabled = true;

  const band = EQ_BANDS[Math.floor(Math.random()*EQ_BANDS.length)];
  const move = Math.random() < 0.5 ? "boost" : "cut";
  eqCurrent = { band, move };

  [...document.querySelectorAll("#eqBandAnswers .answer, #eqMoveAnswers .answer")]
    .forEach(b => {
      b.disabled = false;
      b.classList.remove("correct","wrong");
      b.style.outline = "";
    });

  eqUpdateStats();
}

function eqPickBand(btn, band){
  if(eqLocked) return;
  eqBandGuess = band;

  [...document.querySelectorAll("#eqBandAnswers .answer")].forEach(b=>{
    b.classList.remove("correct","wrong");
    b.style.outline = "";
  });
  btn.style.outline = "2px solid rgba(255,255,255,.35)";

  eqMaybeFinalize();
}

function eqPickMove(btn, move){
  if(eqLocked) return;
  eqMoveGuess = move;

  [...document.querySelectorAll("#eqMoveAnswers .answer")].forEach(b=>{
    b.classList.remove("correct","wrong");
    b.style.outline = "";
  });
  btn.style.outline = "2px solid rgba(255,255,255,.35)";

  eqMaybeFinalize();
}

function eqMaybeFinalize(){
  if(!eqBandGuess || !eqMoveGuess) return;

  eqLocked = true;
  eqAnswered++;

  const bandCorrect = eqBandGuess.id === eqCurrent.band.id;
  const moveCorrect = eqMoveGuess === eqCurrent.move;

  const bandButtons = [...document.querySelectorAll("#eqBandAnswers .answer")];
  const moveButtons = [...document.querySelectorAll("#eqMoveAnswers .answer")];

  [...bandButtons, ...moveButtons].forEach(b=>{
    b.disabled = true;
    b.style.outline = "";
  });

  bandButtons.forEach(b=>{
    if(b.textContent === eqCurrent.band.label) b.classList.add("correct");
  });
  moveButtons.forEach(b=>{
    if(b.textContent.toLowerCase() === (eqCurrent.move === "boost" ? "boost" : "cut")) b.classList.add("correct");
  });

  if(!bandCorrect){
    bandButtons.forEach(b=>{
      if(eqBandGuess && b.textContent === eqBandGuess.label) b.classList.add("wrong");
    });
  }
  if(!moveCorrect){
    moveButtons.forEach(b=>{
      if(eqMoveGuess && b.textContent.toLowerCase() === eqMoveGuess) b.classList.add("wrong");
    });
  }

  let gained = 0;
  if(bandCorrect) gained++;
  if(moveCorrect) gained++;
  eqScore += gained;
  if(gained === 2) eqCorrect++;

  const moveWord = eqCurrent.move === "boost" ? "Boost" : "Cut";
  const resultIcon = gained === 2 ? "‚úÖ" : (gained === 1 ? "üü®" : "‚ùå");

  eqFeedbackEl.innerHTML =
    `${resultIcon} Correct: <b>${eqCurrent.band.label}</b> + <b>${moveWord}</b> ` +
    `<span style="color:var(--muted);">(+${gained} point${gained===1?"":"s"})</span>`;

  eqUpdateStats();
  document.getElementById("eqNext").disabled = false;
}

/* Play helpers: A = original, B = processed, AB = sequence */
function eqPlay(mode="AB"){
  ensureAudio();
  eqStopPlayback();
  if(!eqCurrent) eqNewQuestion();
  if(eqCtx.state === "suspended") eqCtx.resume();

  const src = eqCtx.createBufferSource();
  src.buffer = eqNoiseBuffer;

  const dryGain = eqCtx.createGain();
  dryGain.gain.value = 0.7;

  const filter = eqCtx.createBiquadFilter();
  filter.type = eqCurrent.band.type;
  filter.frequency.value = eqCurrent.band.freq;
  filter.Q.value = eqCurrent.band.q;
  filter.gain.value = (eqCurrent.move === "boost" ? 7 : -7);

  const wetGain = eqCtx.createGain();
  wetGain.gain.value = 0.7;

  const master = eqCtx.createGain();
  master.gain.value = 0.0001;
  master.connect(eqCtx.destination);

  src.connect(dryGain);
  dryGain.connect(master);

  src.connect(filter);
  filter.connect(wetGain);
  wetGain.connect(master);

  const now = eqCtx.currentTime;
  let startTime = now + 0.02;
  let endTime = startTime + 1.25;

  dryGain.gain.setValueAtTime(0.0001, now);
  wetGain.gain.setValueAtTime(0.0001, now);

  if(mode === "A"){
    dryGain.gain.setValueAtTime(0.7, startTime);
    wetGain.gain.setValueAtTime(0.0001, startTime);
    endTime = startTime + 1.25;
  }
  else if(mode === "B"){
    dryGain.gain.setValueAtTime(0.0001, startTime);
    wetGain.gain.setValueAtTime(0.7, startTime);
    endTime = startTime + 1.25;
  }
  else {
    const A_DUR = 1.1;
    const GAP = 0.15;
    const B_DUR = 1.1;
    const A_START = startTime;
    const B_START = A_START + A_DUR + GAP;
    endTime = B_START + B_DUR;

    dryGain.gain.setValueAtTime(0.7, A_START);
    dryGain.gain.setValueAtTime(0.0001, B_START);

    wetGain.gain.setValueAtTime(0.0001, A_START);
    wetGain.gain.setValueAtTime(0.7, B_START);
  }

  master.gain.setValueAtTime(0.0001, now);
  master.gain.exponentialRampToValueAtTime(0.7, startTime + 0.03);
  master.gain.setValueAtTime(0.7, endTime - 0.08);
  master.gain.exponentialRampToValueAtTime(0.0001, endTime);

  src.start(startTime);
  src.stop(endTime + 0.02);

  eqLastSource = src;
  document.getElementById("eqReplay").disabled = false;
}

document.getElementById("eqPlay").onclick = () => {
  if(!eqCurrent) eqNewQuestion();
  eqPlay("AB");
};

document.getElementById("eqReplay").onclick = () => {
  eqPlay("AB");
};

eqPlayABtn.onclick = () => eqPlay("A");
eqPlayBBtn.onclick = () => eqPlay("B");

document.getElementById("eqNext").onclick = () => {
  if(eqAnswered >= EQ_TOTAL_Q){
    eqFeedbackEl.innerHTML = `üéâ Finished! Final Score: <b>${eqScore}/${EQ_TOTAL_Q*2}</b> (2 points per question)`;
    document.getElementById("eqNext").disabled = true;
    return;
  }
  eqNewQuestion();
};

document.getElementById("eqReset").onclick = () => {
  eqScore = 0; eqAnswered = 0; eqCorrect = 0;
  eqUpdateStats();
  eqNewQuestion();
};

/* =====================================================
   INTERVAL TRAINER (Semitone, Third, Fifth, Octave)
===================================================== */

const INT_TOTAL_Q = 30;
const INTERVALS = [
  { id:"semitone", label:"Semitone", semitones:1 },
  { id:"third",    label:"Third",    semitones:4 },
  { id:"fifth",    label:"Fifth",    semitones:7 },
  { id:"octave",   label:"Octave",   semitones:12 }
];

let intScore = 0, intAnswered = 0, intCorrect = 0;
let intLocked = false;
let intCurrent = null;
let intLast = null;

let intModeIndex = 0;
const INT_MODES = ["Ascending", "Descending", "Harmonic"];

const intScoreEl = document.getElementById("intScore");
const intQnumEl  = document.getElementById("intQnum");
const intAccEl   = document.getElementById("intAcc");
const intModeLabelEl = document.getElementById("intModeLabel");

const intAnswersEl = document.getElementById("intAnswers");
const intFeedbackEl = document.getElementById("intFeedback");

const intPlayBtn = document.getElementById("intPlay");
const intReplayBtn = document.getElementById("intReplay");
const intNextBtn = document.getElementById("intNext");
const intResetBtn = document.getElementById("intReset");
const intModeBtn = document.getElementById("intMode");

let intCtx = null;

function intEnsureAudio(){
  if(intCtx) return;
  intCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function midiToFreq(m){
  return 440 * Math.pow(2, (m - 69) / 12);
}

function intShuffle(a){
  return a.slice().sort(() => Math.random() - 0.5);
}

function intUpdateStats(){
  intScoreEl.textContent = String(intScore);
  intQnumEl.textContent = String(Math.min(intAnswered + 1, INT_TOTAL_Q));
  const pct = intAnswered === 0 ? 0 : Math.round((intCorrect / intAnswered) * 100);
  intAccEl.textContent = pct + "%";

  const modeName = INT_MODES[intModeIndex];
  intModeLabelEl.textContent = modeName;
  intModeBtn.textContent = "Mode: " + modeName;
}

function intBuildAnswers(){
  intAnswersEl.innerHTML = "";
  const options = intShuffle(INTERVALS);

  options.forEach(opt => {
    const b = document.createElement("button");
    b.className = "answer";
    b.textContent = opt.label;
    b.onclick = () => intSelectAnswer(b, opt);
    intAnswersEl.appendChild(b);
  });
}

function intNewQuestion(){
  intLocked = false;
  intFeedbackEl.textContent = "";
  intNextBtn.disabled = true;
  intReplayBtn.disabled = true;

  const rootMidi = 52 + Math.floor(Math.random() * 14);
  const interval = INTERVALS[Math.floor(Math.random() * INTERVALS.length)];
  const mode = INT_MODES[intModeIndex];

  intCurrent = { interval, rootMidi, mode };

  intBuildAnswers();
  [...document.querySelectorAll("#intAnswers .answer")].forEach(b=>{
    b.disabled = false;
    b.classList.remove("correct","wrong");
  });

  intUpdateStats();
}

function intStopLast(){
  try{
    if(intLast){
      intLast.forEach(node => { try{ node.stop?.(); }catch(e){} });
      intLast = null;
    }
  }catch(e){}
}

function intPlayInterval(){
  if(!intCurrent) intNewQuestion();
  intEnsureAudio();
  if(intCtx.state === "suspended") intCtx.resume();

  intStopLast();

  const rootF = midiToFreq(intCurrent.rootMidi);
  const intF  = midiToFreq(intCurrent.rootMidi + intCurrent.interval.semitones);

  const master = intCtx.createGain();
  master.gain.value = 0.0001;
  master.connect(intCtx.destination);

  const now = intCtx.currentTime;

  master.gain.setValueAtTime(0.0001, now);
  master.gain.exponentialRampToValueAtTime(0.2, now + 0.02);
  master.gain.setValueAtTime(0.2, now + 0.9);
  master.gain.exponentialRampToValueAtTime(0.0001, now + 1.05);

  function makeOsc(freq, startT, dur){
    const osc = intCtx.createOscillator();
    osc.type = "sine";
    osc.frequency.setValueAtTime(freq, startT);

    const g = intCtx.createGain();
    g.gain.value = 0.0001;

    osc.connect(g);
    g.connect(master);

    g.gain.setValueAtTime(0.0001, startT);
    g.gain.exponentialRampToValueAtTime(1.0, startT + 0.01);
    g.gain.setValueAtTime(1.0, startT + Math.max(0.05, dur - 0.02));
    g.gain.exponentialRampToValueAtTime(0.0001, startT + dur);

    osc.start(startT);
    osc.stop(startT + dur);
    return osc;
  }

  const mode = intCurrent.mode;

  if(mode === "Ascending"){
    const dur = 0.35;
    const gap = 0.07;
    const a = makeOsc(rootF, now + 0.02, dur);
    const b = makeOsc(intF,  now + 0.02 + dur + gap, dur);
    intLast = [a,b];
  } else if(mode === "Descending"){
    const dur = 0.35;
    const gap = 0.07;
    const a = makeOsc(intF,  now + 0.02, dur);
    const b = makeOsc(rootF, now + 0.02 + dur + gap, dur);
    intLast = [a,b];
  } else {
    const dur = 0.7;
    const a = makeOsc(rootF, now + 0.02, dur);
    const b = makeOsc(intF,  now + 0.02, dur);
    intLast = [a,b];
  }

  intReplayBtn.disabled = false;
}

function intSelectAnswer(btn, opt){
  if(intLocked) return;
  intLocked = true;
  intAnswered++;

  const buttons = [...document.querySelectorAll("#intAnswers .answer")];
  buttons.forEach(b => b.disabled = true);

  const isCorrect = (opt.id === intCurrent.interval.id);

  if(isCorrect){
    intScore++;
    intCorrect++;
    btn.classList.add("correct");
    intFeedbackEl.innerHTML = `‚úÖ Correct ‚Äî <b>${intCurrent.interval.label}</b>`;
  } else {
    btn.classList.add("wrong");
    intFeedbackEl.innerHTML = `‚ùå Incorrect ‚Äî Correct answer was <b>${intCurrent.interval.label}</b>`;
    buttons.forEach(b=>{
      if(b.textContent === intCurrent.interval.label) b.classList.add("correct");
    });
  }

  intUpdateStats();
  intNextBtn.disabled = false;
}

intPlayBtn.onclick = () => {
  if(!intCurrent) intNewQuestion();
  intPlayInterval();
};

intReplayBtn.onclick = () => {
  intPlayInterval();
};

intNextBtn.onclick = () => {
  if(intAnswered >= INT_TOTAL_Q){
    intFeedbackEl.innerHTML = `üéâ Finished! Final Score: <b>${intScore}/${INT_TOTAL_Q}</b>`;
    intNextBtn.disabled = true;
    return;
  }
  intNewQuestion();
};

intResetBtn.onclick = () => {
  intScore = 0; intAnswered = 0; intCorrect = 0;
  intUpdateStats();
  intNewQuestion();
};

intModeBtn.onclick = () => {
  intModeIndex = (intModeIndex + 1) % INT_MODES.length;
  intUpdateStats();
};

intUpdateStats();
intNewQuestion();

/* =====================================================
   SECTION 4: STEREO vs MONO IDENTIFICATION
===================================================== */

const ST_TOTAL_Q = 30;
const ST_TYPES = [
  { id:"mono",     label:"Mono" },
  { id:"dualmono", label:"Dual Mono" },
  { id:"wide",     label:"Wide Stereo" },
  { id:"hardpan",  label:"Hard Pan" }
];

let stScore = 0, stAnswered = 0, stCorrect = 0;
let stLocked = false;
let stCurrent = null;     // { typeId, panSide? }
let stLastSource = null;

let stCtx = null;
let stBaseBuffer = null;    // mono buffer used as "source material"
let stNoiseL = null;        // mono noise buffer for L (for wide/hardpan options if needed)
let stNoiseR = null;        // mono noise buffer for R

const stScoreEl = document.getElementById("stScore");
const stQnumEl  = document.getElementById("stQnum");
const stAccEl   = document.getElementById("stAcc");
const stAnswersEl = document.getElementById("stAnswers");
const stFeedbackEl = document.getElementById("stFeedback");

function stUpdateStats(){
  stScoreEl.textContent = String(stScore);
  stQnumEl.textContent = String(Math.min(stAnswered + 1, ST_TOTAL_Q));
  const pct = stAnswered === 0 ? 0 : Math.round((stCorrect / stAnswered) * 100);
  stAccEl.textContent = pct + "%";
}

function stEnsureAudio(){
  if(stCtx) return;
  stCtx = new (window.AudioContext || window.webkitAudioContext)();

  // Build reusable buffers (2.5s)
  const seconds = 2.5;
  const length = Math.floor(stCtx.sampleRate * seconds);

  function makeNoiseBuffer(){
    const buffer = stCtx.createBuffer(1, length, stCtx.sampleRate);
    const out = buffer.getChannelData(0);

    // "pink-ish" noise
    let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
    for(let i=0;i<length;i++){
      const white = Math.random()*2 - 1;
      b0 = 0.99886*b0 + white*0.0555179;
      b1 = 0.99332*b1 + white*0.0750759;
      b2 = 0.96900*b2 + white*0.1538520;
      b3 = 0.86650*b3 + white*0.3104856;
      b4 = 0.55000*b4 + white*0.5329522;
      b5 = -0.7616*b5 - white*0.0168980;
      const pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white*0.5362;
      b6 = white*0.115926;
      out[i] = pink * 0.10;
    }
    return buffer;
  }

  // base mono material: noise + gentle ‚Äútone bed‚Äù amplitude wobble feel (noise is enough for stereo cues)
  stBaseBuffer = makeNoiseBuffer();
  stNoiseL = makeNoiseBuffer();
  stNoiseR = makeNoiseBuffer();
}

function stStop(){
  try{
    if(stLastSource){
      stLastSource.forEach(s => { try{ s.stop(); }catch(e){} });
      stLastSource = null;
    }
  }catch(e){}
}

function stBuildAnswers(){
  stAnswersEl.innerHTML = "";
  const options = shuffle(ST_TYPES);
  options.forEach(opt => {
    const b = document.createElement("button");
    b.className = "answer";
    b.textContent = opt.label;
    b.onclick = () => stSelectAnswer(b, opt);
    stAnswersEl.appendChild(b);
  });
}

function stNewQuestion(){
  stLocked = false;
  stFeedbackEl.textContent = "";
  document.getElementById("stNext").disabled = true;
  document.getElementById("stReplay").disabled = true;

  const t = ST_TYPES[Math.floor(Math.random() * ST_TYPES.length)];
  // For hard pan, choose which side (not shown to student)
  const panSide = (t.id === "hardpan") ? (Math.random() < 0.5 ? "L" : "R") : null;

  stCurrent = { typeId: t.id, panSide };

  stBuildAnswers();
  [...document.querySelectorAll("#stAnswers .answer")].forEach(b=>{
    b.disabled = false;
    b.classList.remove("correct","wrong");
  });

  stUpdateStats();
}

function stSelectAnswer(btn, opt){
  if(stLocked) return;
  stLocked = true;
  stAnswered++;

  const buttons = [...document.querySelectorAll("#stAnswers .answer")];
  buttons.forEach(b => b.disabled = true);

  const correctType = stCurrent.typeId;
  const isCorrect = (opt.id === correctType);

  if(isCorrect){
    stScore++;
    stCorrect++;
    btn.classList.add("correct");
    stFeedbackEl.innerHTML = `‚úÖ Correct ‚Äî <b>${ST_TYPES.find(x=>x.id===correctType).label}</b>`;
  } else {
    btn.classList.add("wrong");
    const corrLabel = ST_TYPES.find(x=>x.id===correctType).label;
    stFeedbackEl.innerHTML = `‚ùå Incorrect ‚Äî Correct answer was <b>${corrLabel}</b>`;
    buttons.forEach(b=>{
      if(b.textContent === corrLabel) b.classList.add("correct");
    });
  }

  stUpdateStats();
  document.getElementById("stNext").disabled = false;
}

/*
  Stereo type definitions (for this trainer):
  - Mono: identical L/R (same buffer).
  - Dual Mono: same source both sides, but tiny delay + tiny level offset on one side (subtle L/R difference).
  - Wide Stereo: stereo widening using decorrelation (uncorrelated noise L/R mixed with some mid).
  - Hard Pan: only L or only R (student just answers Hard Pan).
*/
function stPlay(mode="STEREO"){ // mode: "STEREO" | "L" | "R"
  stEnsureAudio();
  stStop();
  if(!stCurrent) stNewQuestion();
  if(stCtx.state === "suspended") stCtx.resume();

  const now = stCtx.currentTime;

  // Sources
  const srcBase = stCtx.createBufferSource();
  srcBase.buffer = stBaseBuffer;

  const srcL = stCtx.createBufferSource();
  srcL.buffer = stNoiseL;

  const srcR = stCtx.createBufferSource();
  srcR.buffer = stNoiseR;

  // Channel routing to a stereo bus
  const merger = stCtx.createChannelMerger(2);

  // Master envelope
  const master = stCtx.createGain();
  master.gain.value = 0.0001;
  master.connect(stCtx.destination);

  // Gentle fade
  const startT = now + 0.02;
  const dur = 1.6;
  const endT = startT + dur;

  master.gain.setValueAtTime(0.0001, now);
  master.gain.exponentialRampToValueAtTime(0.8, startT + 0.03);
  master.gain.setValueAtTime(0.8, endT - 0.08);
  master.gain.exponentialRampToValueAtTime(0.0001, endT);

  // helper: connect any mono node to L/R with gains and optional delay
  function connectToLR(node, lGainVal, rGainVal, lDelaySec=0, rDelaySec=0){
    const gL = stCtx.createGain(); gL.gain.value = lGainVal;
    const gR = stCtx.createGain(); gR.gain.value = rGainVal;

    let lNode = node;
    let rNode = node;

    if(lDelaySec > 0){
      const dL = stCtx.createDelay(0.05);
      dL.delayTime.value = lDelaySec;
      lNode.connect(dL);
      lNode = dL;
    }
    if(rDelaySec > 0){
      const dR = stCtx.createDelay(0.05);
      dR.delayTime.value = rDelaySec;
      rNode.connect(dR);
      rNode = dR;
    }

    lNode.connect(gL);
    rNode.connect(gR);

    gL.connect(merger, 0, 0);
    gR.connect(merger, 0, 1);
  }

  // Clear route based on current type
  const typeId = stCurrent.typeId;

  if(typeId === "mono"){
    // same base signal both sides
    connectToLR(srcBase, 1.0, 1.0, 0, 0);
  }
  else if(typeId === "dualmono"){
    // same base both sides, but subtle differences (tiny delay + tiny level offset)
    // This makes it NOT fully mono, but still feels mostly centered.
    connectToLR(srcBase, 0.92, 1.00, 0.000, 0.004); // 4ms on R
  }
  else if(typeId === "wide"){
    // Wide: mix some correlated mid + strong uncorrelated side
    // Mid (correlated): base to both sides
    connectToLR(srcBase, 0.55, 0.55, 0, 0);

    // Side (uncorrelated): different noises full L and full R
    // (This is intentionally wide and easy to recognize)
    const gL = stCtx.createGain(); gL.gain.value = 0.65;
    const gR = stCtx.createGain(); gR.gain.value = 0.65;

    // tiny opposing delays to exaggerate width slightly
    const dL = stCtx.createDelay(0.05); dL.delayTime.value = 0.003;
    const dR = stCtx.createDelay(0.05); dR.delayTime.value = 0.011;

    srcL.connect(dL); dL.connect(gL); gL.connect(merger, 0, 0);
    srcR.connect(dR); dR.connect(gR); gR.connect(merger, 0, 1);
  }
  else { // hardpan
    const side = stCurrent.panSide || "L";
    if(side === "L"){
      connectToLR(srcBase, 1.0, 0.0001, 0, 0);
    } else {
      connectToLR(srcBase, 0.0001, 1.0, 0, 0);
    }
  }

  // If user requested L-only or R-only monitoring, apply a post "solo" stage.
  // (We keep the underlying type intact, just mute one output for comparison.)
  const solo = stCtx.createGain();
  solo.gain.value = 1.0;

  // Split the merged stereo into L/R, mute as needed, then recombine.
  const splitter = stCtx.createChannelSplitter(2);
  const postMerger = stCtx.createChannelMerger(2);

  merger.connect(splitter);

  const postGL = stCtx.createGain(); postGL.gain.value = (mode === "R") ? 0.0001 : 1.0;
  const postGR = stCtx.createGain(); postGR.gain.value = (mode === "L") ? 0.0001 : 1.0;

  splitter.connect(postGL, 0);
  splitter.connect(postGR, 1);

  postGL.connect(postMerger, 0, 0);
  postGR.connect(postMerger, 0, 1);

  postMerger.connect(solo);
  solo.connect(master);

  // start/stop sources
  const sources = [srcBase, srcL, srcR];
  sources.forEach(s => { try{ s.start(startT); s.stop(endT + 0.02); }catch(e){} });
  stLastSource = sources;

  document.getElementById("stReplay").disabled = false;
}

document.getElementById("stPlay").onclick = () => {
  if(!stCurrent) stNewQuestion();
  stPlay("STEREO");
};

document.getElementById("stReplay").onclick = () => {
  stPlay("STEREO");
};

document.getElementById("stPlayL").onclick = () => {
  if(!stCurrent) stNewQuestion();
  stPlay("L");
};

document.getElementById("stPlayR").onclick = () => {
  if(!stCurrent) stNewQuestion();
  stPlay("R");
};

document.getElementById("stNext").onclick = () => {
  if(stAnswered >= ST_TOTAL_Q){
    stFeedbackEl.innerHTML = `üéâ Finished! Final Score: <b>${stScore}/${ST_TOTAL_Q}</b>`;
    document.getElementById("stNext").disabled = true;
    return;
  }
  stNewQuestion();
};

document.getElementById("stReset").onclick = () => {
  stScore = 0; stAnswered = 0; stCorrect = 0;
  stUpdateStats();
  stNewQuestion();
};

stUpdateStats();
stNewQuestion();

/* =====================================================
   START APP / PREP
===================================================== */

showView("menu");
newQuestion();          // frequency pre-load
eqBuildAnswerButtons(); // section 3 UI
eqUpdateStats();
eqNewQuestion();
</script>

</body>
</html>
```
