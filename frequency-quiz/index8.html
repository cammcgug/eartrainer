<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Ear Training Hub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root{
      --bg:#0e1118;
      --card:#161b2a;
      --card2:#1e2440;
      --muted:#9aa4b2;
      --text:#e8ecf2;
      --btn:#273050;
      --btnHover:#313c63;
      --good:#1f4d3a;
      --bad:#4d1f2a;
      --radius:16px;
      --shadow:0 20px 40px rgba(0,0,0,.4);
      --font: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:var(--font);
      display:flex;
      justify-content:center;
      min-height:100vh;
      padding:24px;
    }
    .app{ width:900px; max-width:100%; }
    .card{
      background:var(--card);
      border-radius:var(--radius);
      padding:20px;
      box-shadow:var(--shadow);
    }
    h1{ margin:0 0 6px; font-size:22px; }
    .sub{ margin:0 0 16px; color:var(--muted); font-size:14px; }
    .hidden{ display:none !important; }

    /* Menu */
    .menuGrid{
      display:grid;
      grid-template-columns:repeat(3, 1fr);
      gap:12px;
      margin-top:12px;
    }
    @media(max-width:800px){
      .menuGrid{ grid-template-columns:1fr; }
    }
    .menuBtn{
      text-align:left;
      border:none;
      background:var(--card2);
      color:var(--text);
      padding:16px;
      border-radius:14px;
      cursor:pointer;
      transition:background .12s ease, transform .06s ease;
      box-shadow:0 8px 18px rgba(0,0,0,.25);
    }
    .menuBtn:hover{ background:#252d52; }
    .menuBtn:active{ transform:scale(.99); }
    .menuTitle{ font-weight:800; font-size:16px; margin-bottom:6px; }
    .menuDesc{ color:var(--muted); font-size:13px; line-height:1.35; }

    /* Shared UI */
    .top{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      flex-wrap:wrap;
      gap:10px;
    }
    .stats{
      display:flex;
      gap:10px;
      font-size:13px;
      color:var(--muted);
      flex-wrap:wrap;
      align-items:center;
    }
    .pill{
      background:#222840;
      padding:6px 10px;
      border-radius:999px;
    }
    .controls{
      margin-top:14px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    button.action{
      background:var(--btn);
      border:none;
      color:#fff;
      padding:10px 14px;
      border-radius:10px;
      cursor:pointer;
      font-weight:700;
    }
    button.action:hover{ background:var(--btnHover); }
    button.action:disabled{ opacity:.45; cursor:not-allowed; }

    .answers{
      margin-top:18px;
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:10px;
    }
    @media(max-width:600px){
      .answers{ grid-template-columns:1fr; }
    }
    .answer{
      background:var(--card2);
      border-radius:10px;
      padding:12px;
      border:none;
      color:var(--text);
      cursor:pointer;
      font-weight:700;
      text-align:left;
    }
    .answer:hover{ background:#252d52; }
    .answer:disabled{ opacity:.9; cursor:not-allowed; }
    .answer.correct{ background:var(--good) !important; }
    .answer.wrong{ background:var(--bad) !important; }

    .feedback{
      margin-top:14px;
      min-height:22px;
      font-size:14px;
      color:#cfd6e4;
    }

    .backRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-top:14px;
      border-top:1px solid rgba(255,255,255,.08);
      padding-top:14px;
    }
    .smallNote{ color:var(--muted); font-size:12px; line-height:1.35; }

    /* Panels */
    .twoCol{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media(max-width:700px){
      .twoCol{ grid-template-columns:1fr; }
    }
    .panel{
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      padding:12px;
    }
    .panelTitle{
      font-weight:800;
      margin-bottom:6px;
      font-size:13px;
      color:#d7deee;
    }
    .chips{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .chip{
      background:#222840;
      border-radius:999px;
      padding:6px 10px;
      font-size:12px;
      color:#cfd6e4;
    }

    /* Section 3: two clear columns */
    .eqAnswerGrid{
      display:grid;
      grid-template-columns: 2fr 1fr;
      gap:12px;
      margin-top:18px;
    }
    @media(max-width:700px){
      .eqAnswerGrid{ grid-template-columns:1fr; }
    }

    /* Small toggle buttons */
    .segToggle{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .segBtn{
      background:#222840;
      border:1px solid rgba(255,255,255,.10);
      color:#cfd6e4;
      padding:8px 10px;
      border-radius:999px;
      cursor:pointer;
      font-size:12px;
      font-weight:800;
    }
    .segBtn.active{
      outline:2px solid rgba(255,255,255,.28);
      color:#fff;
    }
    input[type="file"]{ display:none; }

    /* Loop UI */
    .loopRow{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
    }
    .loopLabel{
      font-size:12px;
      color:var(--muted);
      min-width:120px;
      font-weight:800;
    }
    .loopSlider{
      flex:1;
      min-width:220px;
    }
    .loopTime{
      font-size:12px;
      color:#cfd6e4;
      background:#222840;
      padding:6px 10px;
      border-radius:999px;
    }
  </style>
</head>

<body>
<div class="app">

  <!-- =========================
       FRONT PAGE / MENU
  ========================== -->
  <div class="card" id="view-menu">
    <h1>Ear Training Hub</h1>
    <p class="sub">Choose a training section.</p>

    <div class="menuGrid">
      <button class="menuBtn" id="go-frequency">
        <div class="menuTitle">Frequency Training</div>
        <div class="menuDesc">Identify pure tones. Multiple choice with scoring.</div>
      </button>

      <button class="menuBtn" id="go-interval">
        <div class="menuTitle">Interval Training</div>
        <div class="menuDesc">Recognize intervals (Semitone, Third, Fifth, Octave).</div>
      </button>

      <button class="menuBtn" id="go-section3">
        <div class="menuTitle">EQ Move Training</div>
        <div class="menuDesc">Compare Original vs Processed, identify band + boost/cut. (Noise or your track)</div>
      </button>

      <button class="menuBtn" id="go-stereo">
        <div class="menuTitle">Stereo vs Mono Identification</div>
        <div class="menuDesc">Identify Mono, Dual Mono, Wide Stereo, or Hard Pan. (Noise or your track)</div>
      </button>
    </div>

    <div class="backRow">
      <div class="smallNote">
        Folder setup: <b>index.html</b> + <b>audio/</b> (your mp3s).
      </div>
    </div>
  </div>

  <!-- =========================
       FREQUENCY TRAINING
  ========================== -->
  <div class="card hidden" id="view-frequency">
    <div class="top">
      <div>
        <h1>Frequency Training</h1>
        <p class="sub">Press Play, then choose the correct frequency.</p>
      </div>
      <div class="stats">
        <div class="pill">Score: <span id="score">0</span></div>
        <div class="pill">Question: <span id="qnum">1</span>/30</div>
        <div class="pill">Accuracy: <span id="acc">0%</span></div>
      </div>
    </div>

    <div class="controls">
      <button class="action" id="play">‚ñ∂ Play</button>
      <button class="action" id="replay" disabled>‚Üª Replay</button>
      <button class="action" id="next" disabled>Next ‚Üí</button>
      <button class="action" id="reset" style="margin-left:auto;">Reset</button>
    </div>

    <div class="answers" id="answers"></div>
    <div class="feedback" id="feedback"></div>

    <div class="backRow">
      <button class="action" id="backFromFrequency">‚Üê Back to Menu</button>
      <div class="smallNote">Tip: let students replay before answering.</div>
    </div>
  </div>

  <!-- =========================
       INTERVAL TRAINING
  ========================== -->
  <div class="card hidden" id="view-interval">
    <div class="top">
      <div>
        <h1>Interval Training</h1>
        <p class="sub">Press Play, then identify the interval (Semitone, Third, Fifth, Octave).</p>
      </div>
      <div class="stats">
        <div class="pill">Score: <span id="intScore">0</span></div>
        <div class="pill">Question: <span id="intQnum">1</span>/30</div>
        <div class="pill">Accuracy: <span id="intAcc">0%</span></div>
        <div class="pill">Mode: <span id="intModeLabel">Ascending</span></div>
      </div>
    </div>

    <div class="controls">
      <button class="action" id="intPlay">‚ñ∂ Play</button>
      <button class="action" id="intReplay" disabled>‚Üª Replay</button>
      <button class="action" id="intNext" disabled>Next ‚Üí</button>

      <button class="action" id="intMode" style="margin-left:auto;">Mode: Ascending</button>
      <button class="action" id="intReset">Reset</button>
    </div>

    <div class="answers" id="intAnswers"></div>
    <div class="feedback" id="intFeedback"></div>

    <div class="backRow">
      <button class="action" id="backFromInterval">‚Üê Back to Menu</button>
      <div class="smallNote">Tip: start with Ascending.</div>
    </div>
  </div>

  <!-- =========================
       SECTION 3: EQ MOVE TRAINING
  ========================== -->
  <div class="card hidden" id="view-section3">
    <div class="top">
      <div>
        <h1>EQ Move Training</h1>
        <p class="sub">
          Compare <b>Original</b> vs <b>Processed</b>, then pick the <b>band</b> and <b>boost</b>/<b>cut</b>.
        </p>

        <div class="segToggle" style="margin-top:10px;">
          <button class="segBtn active" id="eqUseNoiseBtn">Use Noise</button>
          <button class="segBtn" id="eqUseTrackBtn">Use My Track</button>
          <button class="segBtn" id="eqLoadBtn">Upload Track</button>
          <span class="chip" id="eqTrackLabel" style="opacity:.9;">No track loaded</span>
        </div>
        <input type="file" id="eqFile" accept="audio/*" />

        <!-- Loop selector -->
        <div class="loopRow" id="eqLoopRow">
          <div class="loopLabel">Loop Start (4s)</div>
          <input class="loopSlider" type="range" id="eqLoop" min="0" max="0" step="0.01" value="0" disabled />
          <div class="loopTime" id="eqLoopTime">0.00s</div>
          <button class="action" id="eqPreview" disabled>Preview Loop</button>
        </div>
      </div>

      <div class="stats">
        <div class="pill">Score: <span id="eqScore">0</span></div>
        <div class="pill">Question: <span id="eqQnum">1</span>/30</div>
        <div class="pill">Accuracy: <span id="eqAcc">0%</span></div>
      </div>
    </div>

    <div class="twoCol">
      <div class="panel">
        <div class="panelTitle">Bands (broad mix zones)</div>
        <div class="chips">
          <div class="chip">Sub (20‚Äì60)</div>
          <div class="chip">Bass (60‚Äì200)</div>
          <div class="chip">Low-Mid (200‚Äì600)</div>
          <div class="chip">Mid (600‚Äì2k)</div>
          <div class="chip">High-Mid (2‚Äì6k)</div>
          <div class="chip">Air (8k+)</div>
        </div>
      </div>

      <div class="panel">
        <div class="panelTitle">How it works</div>
        <div class="smallNote">
          Use <b>Play A</b> (Original) and <b>Play B</b> (Processed).  
          When using your track, A/B plays <b>4 seconds</b> from the selected loop point.
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="action" id="eqPlay">‚ñ∂ Play AB</button>
      <button class="action" id="eqReplay" disabled>‚Üª Replay AB</button>
      <button class="action" id="eqNext" disabled>Next ‚Üí</button>

      <button class="action" id="eqPlayA" style="margin-left:auto;">Play A</button>
      <button class="action" id="eqPlayB">Play B</button>

      <button class="action" id="eqReset">Reset</button>
    </div>

    <div class="eqAnswerGrid">
      <div>
        <div class="panelTitle" style="margin:6px 0 8px;">Pick the band</div>
        <div class="answers" id="eqBandAnswers"></div>
      </div>
      <div>
        <div class="panelTitle" style="margin:6px 0 8px;">Boost or Cut?</div>
        <div class="answers" id="eqMoveAnswers"></div>
      </div>
    </div>

    <div class="feedback" id="eqFeedback"></div>

    <div class="backRow">
      <button class="action" id="backFromSection3">‚Üê Back to Menu</button>
      <div class="smallNote">Tip: widen difficulty by changing boost/cut amount later.</div>
    </div>
  </div>

  <!-- =========================
       SECTION 4: STEREO vs MONO IDENTIFICATION
  ========================== -->
  <div class="card hidden" id="view-stereo">
    <div class="top">
      <div>
        <h1>Stereo vs Mono Identification</h1>
        <p class="sub">Press Play, then identify: <b>Mono</b>, <b>Dual Mono</b>, <b>Wide Stereo</b>, or <b>Hard Pan</b>.</p>

        <div class="segToggle" style="margin-top:10px;">
          <button class="segBtn active" id="stUseNoiseBtn">Use Noise</button>
          <button class="segBtn" id="stUseTrackBtn">Use My Track</button>
          <button class="segBtn" id="stLoadBtn">Upload Track</button>
          <span class="chip" id="stTrackLabel" style="opacity:.9;">No track loaded</span>
        </div>
        <input type="file" id="stFile" accept="audio/*" />

        <!-- Loop selector -->
        <div class="loopRow" id="stLoopRow">
          <div class="loopLabel">Loop Start (4s)</div>
          <input class="loopSlider" type="range" id="stLoop" min="0" max="0" step="0.01" value="0" disabled />
          <div class="loopTime" id="stLoopTime">0.00s</div>
          <button class="action" id="stPreview" disabled>Preview Loop</button>
        </div>
      </div>

      <div class="stats">
        <div class="pill">Score: <span id="stScore">0</span></div>
        <div class="pill">Question: <span id="stQnum">1</span>/30</div>
        <div class="pill">Accuracy: <span id="stAcc">0%</span></div>
      </div>
    </div>

    <div class="twoCol">
      <div class="panel">
        <div class="panelTitle">What to listen for</div>
        <div class="smallNote">
          <ul style="margin:8px 0 0 18px; color:var(--muted);">
            <li><b>Mono:</b> centered, same in both ears.</li>
            <li><b>Dual Mono:</b> mostly centered, subtle L/R differences.</li>
            <li><b>Wide Stereo:</b> noticeably wide.</li>
            <li><b>Hard Pan:</b> mostly one side.</li>
          </ul>
        </div>
      </div>
      <div class="panel">
        <div class="panelTitle">Quick compare tools</div>
        <div class="smallNote">
          Use <b>Play L</b> / <b>Play R</b> to check each side.  
          With your track, playback is <b>4 seconds</b> from the selected loop point.
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="action" id="stPlay">‚ñ∂ Play</button>
      <button class="action" id="stReplay" disabled>‚Üª Replay</button>
      <button class="action" id="stNext" disabled>Next ‚Üí</button>

      <button class="action" id="stPlayL" style="margin-left:auto;">Play L</button>
      <button class="action" id="stPlayR">Play R</button>

      <button class="action" id="stReset">Reset</button>
    </div>

    <div class="answers" id="stAnswers"></div>
    <div class="feedback" id="stFeedback"></div>

    <div class="backRow">
      <button class="action" id="backFromStereo">‚Üê Back to Menu</button>
      <div class="smallNote">Tip: headphones make this much easier.</div>
    </div>
  </div>

</div>

<audio id="player"></audio>

<script>
/* =====================================================
   VIEW ROUTER
===================================================== */
const views = {
  menu: document.getElementById("view-menu"),
  frequency: document.getElementById("view-frequency"),
  interval: document.getElementById("view-interval"),
  section3: document.getElementById("view-section3"),
  stereo: document.getElementById("view-stereo")
};

function showView(name){
  Object.values(views).forEach(v => v.classList.add("hidden"));
  views[name].classList.remove("hidden");
}

document.getElementById("go-frequency").onclick = () => showView("frequency");
document.getElementById("go-interval").onclick = () => showView("interval");
document.getElementById("go-section3").onclick = () => showView("section3");
document.getElementById("go-stereo").onclick = () => showView("stereo");

document.getElementById("backFromFrequency").onclick = () => showView("menu");
document.getElementById("backFromInterval").onclick = () => showView("menu");
document.getElementById("backFromSection3").onclick = () => showView("menu");
document.getElementById("backFromStereo").onclick = () => showView("menu");

/* =====================================================
   UTIL
===================================================== */
function shuffle(a){ return a.slice().sort(() => Math.random() - 0.5); }
function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
function fmtTime(s){ return (Math.round(s*100)/100).toFixed(2) + "s"; }

async function decodeFileToBuffer(file, audioCtx){
  const arr = await file.arrayBuffer();
  return await audioCtx.decodeAudioData(arr);
}

/* =====================================================
   FREQUENCY TRAINER
===================================================== */
const FILES = [
  { label:"80 Hz", file:"audio/1..mp3" },
  { label:"100 Hz", file:"audio/2_.mp3" },
  { label:"125 Hz", file:"audio/3..mp3" },
  { label:"250 Hz", file:"audio/4..mp3" },
  { label:"315 Hz", file:"audio/5..mp3" },
  { label:"400 Hz", file:"audio/6..mp3" },
  { label:"500 Hz", file:"audio/7_.mp3" },
  { label:"630 Hz", file:"audio/8..mp3" },
  { label:"800 Hz", file:"audio/9..mp3" },
  { label:"1 kHz", file:"audio/10_.mp3" },
  { label:"2 kHz", file:"audio/11_.mp3" },
  { label:"2.5 kHz", file:"audio/12..mp3" },
  { label:"3.15 kHz", file:"audio/13..mp3" },
  { label:"4 kHz", file:"audio/14..mp3" },
  { label:"5 kHz", file:"audio/15_.mp3" },
  { label:"6.3 kHz", file:"audio/16..mp3" },
  { label:"8 kHz", file:"audio/17..mp3" },
  { label:"10 kHz", file:"audio/18_.mp3" },
  { label:"12 kHz", file:"audio/19_.mp3" },
  { label:"14 kHz", file:"audio/20..mp3" },
  { label:"1 kHz", file:"audio/21_.mp3" },
  { label:"250 Hz", file:"audio/22..mp3" },
  { label:"500 Hz", file:"audio/23_.mp3" },
  { label:"2.15 kHz", file:"audio/24..mp3" },
  { label:"5 kHz", file:"audio/25_.mp3" },
  { label:"10 kHz", file:"audio/26_.mp3" },
  { label:"630 Hz", file:"audio/27..mp3" },
  { label:"125 Hz", file:"audio/28..mp3" },
  { label:"60 Hz", file:"audio/29_.mp3" },
  { label:"10 kHz", file:"audio/30_.mp3" }
];

const ANSWERS_PER_Q = 5;
let pool = [];
let current = null;
let locked = false;

let score = 0;
let answered = 0;
let correct = 0;

const player = document.getElementById("player");
const answersEl = document.getElementById("answers");
const feedbackEl = document.getElementById("feedback");
const scoreEl = document.getElementById("score");
const qnumEl = document.getElementById("qnum");
const accEl = document.getElementById("acc");

function refillPool(){ if(pool.length === 0) pool = shuffle(FILES); }

function updateStats(){
  scoreEl.textContent = String(score);
  qnumEl.textContent = String(Math.min(answered + 1, FILES.length));
  const pct = answered === 0 ? 0 : Math.round((correct/answered)*100);
  accEl.textContent = pct + "%";
}

function newQuestion(){
  locked = false;
  feedbackEl.textContent = "";
  document.getElementById("next").disabled = true;
  document.getElementById("replay").disabled = true;

  refillPool();
  current = pool.pop();

  const decoys = shuffle(FILES.filter(f => f !== current)).slice(0, ANSWERS_PER_Q - 1);
  const options = shuffle([current, ...decoys]);

  answersEl.innerHTML = "";
  options.forEach(item => {
    const b = document.createElement("button");
    b.className = "answer";
    b.textContent = item.label;
    b.onclick = () => selectAnswer(b, item);
    answersEl.appendChild(b);
  });

  updateStats();
}

function selectAnswer(btn, item){
  if(locked) return;
  locked = true;
  answered++;

  const buttons = document.querySelectorAll("#answers .answer");
  buttons.forEach(b => b.disabled = true);

  if(item === current){
    score++; correct++;
    btn.classList.add("correct");
    feedbackEl.innerHTML = `‚úÖ Correct ‚Äî <b>${current.label}</b>`;
  } else {
    btn.classList.add("wrong");
    feedbackEl.innerHTML = `‚ùå Incorrect ‚Äî Correct answer was <b>${current.label}</b>`;
    buttons.forEach(b => { if(b.textContent === current.label) b.classList.add("correct"); });
  }

  updateStats();
  document.getElementById("next").disabled = false;
}

document.getElementById("play").onclick = () => {
  if(!current) newQuestion();
  player.src = current.file;
  player.play();
  document.getElementById("replay").disabled = false;
};
document.getElementById("replay").onclick = () => { player.currentTime = 0; player.play(); };
document.getElementById("next").onclick = () => {
  if(answered >= FILES.length){
    feedbackEl.innerHTML = `üéâ Finished! Final Score: <b>${score}/${FILES.length}</b>`;
    document.getElementById("next").disabled = true;
    return;
  }
  newQuestion();
};
document.getElementById("reset").onclick = () => {
  score = 0; answered = 0; correct = 0;
  pool = [];
  updateStats();
  newQuestion();
};

/* =====================================================
   SECTION 3: EQ MOVE TRAINING
===================================================== */
const EQ_TOTAL_Q = 30;
const EQ_TRACK_LOOP_LEN = 4.0;         // requested 4 seconds
const EQ_NOISE_SEG_LEN = 1.35;         // keep noise short
const EQ_NOISE_GAP = 0.18;
const EQ_TRACK_GAP = 0.20;

const EQ_BANDS = [
  { id:"sub",     label:"Sub (20‚Äì60 Hz)",     type:"lowshelf",  freq:45,    q:0.7 },
  { id:"bass",    label:"Bass (60‚Äì200 Hz)",   type:"peaking",   freq:110,   q:1.0 },
  { id:"lowmid",  label:"Low-Mid (200‚Äì600)",  type:"peaking",   freq:350,   q:1.1 },
  { id:"mid",     label:"Mid (600‚Äì2k)",       type:"peaking",   freq:1200,  q:1.0 },
  { id:"highmid", label:"High-Mid (2‚Äì6k)",    type:"peaking",   freq:3500,  q:1.0 },
  { id:"air",     label:"Air (8k+)",          type:"highshelf", freq:11000, q:0.7 }
];

let eqScore = 0, eqAnswered = 0, eqCorrect = 0;
let eqLocked = false;

let eqCtx = null;
let eqNoiseBuffer = null;
let eqTrackBuffer = null;
let eqUseTrack = false;

let eqLoopStart = 0; // seconds
const eqLoopSlider = document.getElementById("eqLoop");
const eqLoopTime = document.getElementById("eqLoopTime");
const eqPreviewBtn = document.getElementById("eqPreview");

let eqCurrent = null;
let eqBandGuess = null;
let eqMoveGuess = null;
let eqLastSources = null;

const eqScoreEl = document.getElementById("eqScore");
const eqQnumEl  = document.getElementById("eqQnum");
const eqAccEl   = document.getElementById("eqAcc");
const eqFeedbackEl = document.getElementById("eqFeedback");

const eqBandAnswersEl = document.getElementById("eqBandAnswers");
const eqMoveAnswersEl = document.getElementById("eqMoveAnswers");

const eqUseNoiseBtn = document.getElementById("eqUseNoiseBtn");
const eqUseTrackBtn = document.getElementById("eqUseTrackBtn");
const eqLoadBtn = document.getElementById("eqLoadBtn");
const eqFile = document.getElementById("eqFile");
const eqTrackLabel = document.getElementById("eqTrackLabel");

function eqUpdateStats(){
  eqScoreEl.textContent = String(eqScore);
  eqQnumEl.textContent = String(Math.min(eqAnswered + 1, EQ_TOTAL_Q));
  const pct = eqAnswered === 0 ? 0 : Math.round((eqCorrect/eqAnswered)*100);
  eqAccEl.textContent = pct + "%";
}

function eqEnsureAudio(){
  if(eqCtx) return;
  eqCtx = new (window.AudioContext || window.webkitAudioContext)();

  // Reusable pink-ish noise buffer (3s)
  const seconds = 3;
  const length = Math.floor(eqCtx.sampleRate * seconds);
  const buffer = eqCtx.createBuffer(1, length, eqCtx.sampleRate);
  const out = buffer.getChannelData(0);

  let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
  for(let i=0;i<length;i++){
    const white = Math.random()*2 - 1;
    b0 = 0.99886*b0 + white*0.0555179;
    b1 = 0.99332*b1 + white*0.0750759;
    b2 = 0.96900*b2 + white*0.1538520;
    b3 = 0.86650*b3 + white*0.3104856;
    b4 = 0.55000*b4 + white*0.5329522;
    b5 = -0.7616*b5 - white*0.0168980;
    const pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white*0.5362;
    b6 = white*0.115926;
    out[i] = pink * 0.11;
  }
  eqNoiseBuffer = buffer;
}

function eqStopPlayback(){
  try{
    if(eqLastSources){
      eqLastSources.forEach(s => { try{ s.stop(); }catch(e){} });
      eqLastSources = null;
    }
  }catch(e){}
}

function eqGetSourceBuffer(){
  if(eqUseTrack && eqTrackBuffer) return eqTrackBuffer;
  return eqNoiseBuffer;
}

function eqGetLoopLenForCurrent(){
  if(eqUseTrack && eqTrackBuffer){
    return Math.min(EQ_TRACK_LOOP_LEN, eqTrackBuffer.duration);
  }
  return EQ_NOISE_SEG_LEN; // for noise, we treat segment length as a "listen window"
}

function eqConfigureLoopUI(){
  // Enable loop UI only when track loaded + use track
  const hasTrack = !!eqTrackBuffer;
  const loopLen = hasTrack ? Math.min(EQ_TRACK_LOOP_LEN, eqTrackBuffer.duration) : EQ_TRACK_LOOP_LEN;

  if(hasTrack){
    const maxStart = Math.max(0, eqTrackBuffer.duration - loopLen);
    eqLoopStart = clamp(eqLoopStart, 0, maxStart);

    eqLoopSlider.disabled = false;
    eqLoopSlider.min = "0";
    eqLoopSlider.max = String(maxStart);
    eqLoopSlider.step = "0.01";
    eqLoopSlider.value = String(eqLoopStart);
    eqLoopTime.textContent = fmtTime(eqLoopStart);
    eqPreviewBtn.disabled = !eqUseTrack; // preview only meaningful in track mode
  } else {
    eqLoopStart = 0;
    eqLoopSlider.disabled = true;
    eqLoopSlider.min = "0";
    eqLoopSlider.max = "0";
    eqLoopSlider.value = "0";
    eqLoopTime.textContent = "0.00s";
    eqPreviewBtn.disabled = true;
  }
}

eqLoopSlider.oninput = (e) => {
  eqLoopStart = parseFloat(e.target.value || "0");
  eqLoopTime.textContent = fmtTime(eqLoopStart);
};

function eqBuildAnswerButtons(){
  eqBandAnswersEl.innerHTML = "";
  EQ_BANDS.forEach(band => {
    const btn = document.createElement("button");
    btn.className = "answer";
    btn.textContent = band.label;
    btn.onclick = () => eqPickBand(btn, band);
    eqBandAnswersEl.appendChild(btn);
  });

  eqMoveAnswersEl.innerHTML = "";
  ["Boost", "Cut"].forEach(txt => {
    const btn = document.createElement("button");
    btn.className = "answer";
    btn.textContent = txt;
    btn.onclick = () => eqPickMove(btn, txt.toLowerCase());
    eqMoveAnswersEl.appendChild(btn);
  });
}

function eqNewQuestion(){
  eqLocked = false;
  eqBandGuess = null;
  eqMoveGuess = null;
  eqFeedbackEl.textContent = "";
  document.getElementById("eqNext").disabled = true;
  document.getElementById("eqReplay").disabled = true;

  const band = EQ_BANDS[Math.floor(Math.random()*EQ_BANDS.length)];
  const move = Math.random() < 0.5 ? "boost" : "cut";
  eqCurrent = { band, move };

  [...document.querySelectorAll("#eqBandAnswers .answer, #eqMoveAnswers .answer")]
    .forEach(b => {
      b.disabled = false;
      b.classList.remove("correct","wrong");
      b.style.outline = "";
    });

  eqUpdateStats();
}

function eqPickBand(btn, band){
  if(eqLocked) return;
  eqBandGuess = band;

  [...document.querySelectorAll("#eqBandAnswers .answer")].forEach(b=>{
    b.classList.remove("correct","wrong");
    b.style.outline = "";
  });
  btn.style.outline = "2px solid rgba(255,255,255,.35)";
  eqMaybeFinalize();
}

function eqPickMove(btn, move){
  if(eqLocked) return;
  eqMoveGuess = move;

  [...document.querySelectorAll("#eqMoveAnswers .answer")].forEach(b=>{
    b.classList.remove("correct","wrong");
    b.style.outline = "";
  });
  btn.style.outline = "2px solid rgba(255,255,255,.35)";
  eqMaybeFinalize();
}

function eqMaybeFinalize(){
  if(!eqBandGuess || !eqMoveGuess) return;

  eqLocked = true;
  eqAnswered++;

  const bandCorrect = eqBandGuess.id === eqCurrent.band.id;
  const moveCorrect = eqMoveGuess === eqCurrent.move;

  const bandButtons = [...document.querySelectorAll("#eqBandAnswers .answer")];
  const moveButtons = [...document.querySelectorAll("#eqMoveAnswers .answer")];

  [...bandButtons, ...moveButtons].forEach(b=>{
    b.disabled = true;
    b.style.outline = "";
  });

  bandButtons.forEach(b=>{
    if(b.textContent === eqCurrent.band.label) b.classList.add("correct");
  });
  moveButtons.forEach(b=>{
    if(b.textContent.toLowerCase() === (eqCurrent.move === "boost" ? "boost" : "cut")) b.classList.add("correct");
  });

  if(!bandCorrect){
    bandButtons.forEach(b=>{
      if(eqBandGuess && b.textContent === eqBandGuess.label) b.classList.add("wrong");
    });
  }
  if(!moveCorrect){
    moveButtons.forEach(b=>{
      if(eqMoveGuess && b.textContent.toLowerCase() === eqMoveGuess) b.classList.add("wrong");
    });
  }

  let gained = 0;
  if(bandCorrect) gained++;
  if(moveCorrect) gained++;
  eqScore += gained;
  if(gained === 2) eqCorrect++;

  const moveWord = eqCurrent.move === "boost" ? "Boost" : "Cut";
  const resultIcon = gained === 2 ? "‚úÖ" : (gained === 1 ? "üü®" : "‚ùå");

  eqFeedbackEl.innerHTML =
    `${resultIcon} Correct: <b>${eqCurrent.band.label}</b> + <b>${moveWord}</b> ` +
    `<span style="color:var(--muted);">(+${gained} point${gained===1?"":"s"})</span>`;

  eqUpdateStats();
  document.getElementById("eqNext").disabled = false;
}

/* EQ Playback:
   mode = "A" (dry) | "B" (processed) | "AB" (A then B)
   - Track mode plays 4 seconds from loop start.
   - Noise mode stays short.
*/
function eqPlay(mode="AB"){
  eqEnsureAudio();
  eqStopPlayback();
  if(!eqCurrent) eqNewQuestion();
  if(eqCtx.state === "suspended") eqCtx.resume();

  const buffer = eqGetSourceBuffer();
  if(!buffer){
    eqFeedbackEl.innerHTML = `‚ö†Ô∏è Audio not ready yet. Try again.`;
    return;
  }

  const usingTrack = (eqUseTrack && eqTrackBuffer);
  const loopLen = usingTrack ? Math.min(EQ_TRACK_LOOP_LEN, buffer.duration) : EQ_NOISE_SEG_LEN;
  const gap = usingTrack ? EQ_TRACK_GAP : EQ_NOISE_GAP;

  // make source
  const src = eqCtx.createBufferSource();
  src.buffer = buffer;

  // dry/wet split
  const dryGain = eqCtx.createGain();
  const wetGain = eqCtx.createGain();

  // filter
  const filter = eqCtx.createBiquadFilter();
  filter.type = eqCurrent.band.type;
  filter.frequency.value = eqCurrent.band.freq;
  filter.Q.value = eqCurrent.band.q;
  filter.gain.value = (eqCurrent.move === "boost" ? 7 : -7);

  // master
  const master = eqCtx.createGain();
  master.gain.value = 0.0001;
  master.connect(eqCtx.destination);

  // routing
  src.connect(dryGain); dryGain.connect(master);
  src.connect(filter);  filter.connect(wetGain); wetGain.connect(master);

  const now = eqCtx.currentTime;
  const startT = now + 0.02;

  // decide offsets / durations
  const offset = usingTrack ? clamp(eqLoopStart, 0, Math.max(0, buffer.duration - loopLen)) : 0;

  let aStart = startT;
  let bStart = startT + loopLen + gap;
  let endT = startT + loopLen;

  // set gains
  dryGain.gain.setValueAtTime(0.0001, now);
  wetGain.gain.setValueAtTime(0.0001, now);

  if(mode === "A"){
    dryGain.gain.setValueAtTime(0.85, aStart);
    wetGain.gain.setValueAtTime(0.0001, aStart);
    endT = aStart + loopLen;
  } else if(mode === "B"){
    dryGain.gain.setValueAtTime(0.0001, aStart);
    wetGain.gain.setValueAtTime(0.85, aStart);
    endT = aStart + loopLen;
  } else {
    // AB sequence (A then B)
    dryGain.gain.setValueAtTime(0.85, aStart);
    dryGain.gain.setValueAtTime(0.0001, bStart);

    wetGain.gain.setValueAtTime(0.0001, aStart);
    wetGain.gain.setValueAtTime(0.85, bStart);

    endT = bStart + loopLen;
  }

  // fade
  master.gain.setValueAtTime(0.0001, now);
  master.gain.exponentialRampToValueAtTime(0.75, startT + 0.03);
  master.gain.setValueAtTime(0.75, endT - 0.08);
  master.gain.exponentialRampToValueAtTime(0.0001, endT);

  // start/stop (use offset only for track)
  if(usingTrack){
    // start(when, offset, duration)
    // For AB, we reuse same source; it plays continuously, while we switch dry/wet gains.
    src.start(aStart, offset, (mode === "AB") ? (2*loopLen + gap) : loopLen);
    src.stop(endT + 0.02);
  } else {
    // noise buffer is 3s; just start at 0
    src.start(aStart);
    src.stop(endT + 0.02);
  }

  eqLastSources = [src];
  document.getElementById("eqReplay").disabled = false;
}

document.getElementById("eqPlay").onclick = () => eqPlay("AB");
document.getElementById("eqReplay").onclick = () => eqPlay("AB");
document.getElementById("eqPlayA").onclick = () => eqPlay("A");
document.getElementById("eqPlayB").onclick = () => eqPlay("B");

document.getElementById("eqNext").onclick = () => {
  if(eqAnswered >= EQ_TOTAL_Q){
    eqFeedbackEl.innerHTML = `üéâ Finished! Final Score: <b>${eqScore}/${EQ_TOTAL_Q*2}</b> (2 points per question)`;
    document.getElementById("eqNext").disabled = true;
    return;
  }
  eqNewQuestion();
};

document.getElementById("eqReset").onclick = () => {
  eqScore = 0; eqAnswered = 0; eqCorrect = 0;
  eqUpdateStats();
  eqNewQuestion();
};

function eqRefreshToggleUI(){
  eqUseNoiseBtn.classList.toggle("active", !eqUseTrack);
  eqUseTrackBtn.classList.toggle("active", !!eqUseTrack);
  if(eqUseTrack && !eqTrackBuffer) eqTrackLabel.textContent = "No track loaded";
  eqConfigureLoopUI();
}

eqUseNoiseBtn.onclick = () => { eqUseTrack = false; eqRefreshToggleUI(); };
eqUseTrackBtn.onclick = () => { eqUseTrack = true;  eqRefreshToggleUI(); };

eqLoadBtn.onclick = () => { eqEnsureAudio(); eqFile.click(); };

eqFile.onchange = async (e) => {
  const file = e.target.files?.[0];
  if(!file) return;
  eqEnsureAudio();
  try{
    eqTrackLabel.textContent = "Loading‚Ä¶";
    const buf = await decodeFileToBuffer(file, eqCtx);
    eqTrackBuffer = buf;
    eqUseTrack = true;
    eqTrackLabel.textContent = file.name;
    eqLoopStart = 0;
    eqRefreshToggleUI();
  }catch(err){
    eqTrackBuffer = null;
    eqTrackLabel.textContent = "Could not load track";
    eqFeedbackEl.innerHTML = `‚ö†Ô∏è Could not decode this file. Try WAV/MP3.`;
    eqUseTrack = false;
    eqRefreshToggleUI();
  }
};

// Preview loop (dry)
eqPreviewBtn.onclick = () => {
  if(!eqTrackBuffer) return;
  eqUseTrack = true;
  eqRefreshToggleUI();
  eqPlay("A");
};

/* =====================================================
   INTERVAL TRAINER
===================================================== */
const INT_TOTAL_Q = 30;
const INTERVALS = [
  { id:"semitone", label:"Semitone", semitones:1 },
  { id:"third",    label:"Third",    semitones:4 },
  { id:"fifth",    label:"Fifth",    semitones:7 },
  { id:"octave",   label:"Octave",   semitones:12 }
];

let intScore = 0, intAnswered = 0, intCorrect = 0;
let intLocked = false;
let intCurrent = null;
let intLast = null;

let intModeIndex = 0;
const INT_MODES = ["Ascending", "Descending", "Harmonic"];

const intScoreEl = document.getElementById("intScore");
const intQnumEl  = document.getElementById("intQnum");
const intAccEl   = document.getElementById("intAcc");
const intModeLabelEl = document.getElementById("intModeLabel");

const intAnswersEl = document.getElementById("intAnswers");
const intFeedbackEl = document.getElementById("intFeedback");

const intPlayBtn = document.getElementById("intPlay");
const intReplayBtn = document.getElementById("intReplay");
const intNextBtn = document.getElementById("intNext");
const intResetBtn = document.getElementById("intReset");
const intModeBtn = document.getElementById("intMode");

let intCtx = null;

function intEnsureAudio(){
  if(intCtx) return;
  intCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function midiToFreq(m){ return 440 * Math.pow(2, (m - 69) / 12); }

function intUpdateStats(){
  intScoreEl.textContent = String(intScore);
  intQnumEl.textContent = String(Math.min(intAnswered + 1, INT_TOTAL_Q));
  const pct = intAnswered === 0 ? 0 : Math.round((intCorrect / intAnswered) * 100);
  intAccEl.textContent = pct + "%";

  const modeName = INT_MODES[intModeIndex];
  intModeLabelEl.textContent = modeName;
  intModeBtn.textContent = "Mode: " + modeName;
}

function intBuildAnswers(){
  intAnswersEl.innerHTML = "";
  const options = shuffle(INTERVALS);
  options.forEach(opt => {
    const b = document.createElement("button");
    b.className = "answer";
    b.textContent = opt.label;
    b.onclick = () => intSelectAnswer(b, opt);
    intAnswersEl.appendChild(b);
  });
}

function intNewQuestion(){
  intLocked = false;
  intFeedbackEl.textContent = "";
  intNextBtn.disabled = true;
  intReplayBtn.disabled = true;

  const rootMidi = 52 + Math.floor(Math.random() * 14);
  const interval = INTERVALS[Math.floor(Math.random() * INTERVALS.length)];
  const mode = INT_MODES[intModeIndex];
  intCurrent = { interval, rootMidi, mode };

  intBuildAnswers();
  [...document.querySelectorAll("#intAnswers .answer")].forEach(b=>{
    b.disabled = false;
    b.classList.remove("correct","wrong");
  });

  intUpdateStats();
}

function intStopLast(){
  try{
    if(intLast){
      intLast.forEach(node => { try{ node.stop?.(); }catch(e){} });
      intLast = null;
    }
  }catch(e){}
}

function intPlayInterval(){
  if(!intCurrent) intNewQuestion();
  intEnsureAudio();
  if(intCtx.state === "suspended") intCtx.resume();

  intStopLast();

  const rootF = midiToFreq(intCurrent.rootMidi);
  const intF  = midiToFreq(intCurrent.rootMidi + intCurrent.interval.semitones);

  const master = intCtx.createGain();
  master.gain.value = 0.0001;
  master.connect(intCtx.destination);

  const now = intCtx.currentTime;

  master.gain.setValueAtTime(0.0001, now);
  master.gain.exponentialRampToValueAtTime(0.2, now + 0.02);
  master.gain.setValueAtTime(0.2, now + 0.9);
  master.gain.exponentialRampToValueAtTime(0.0001, now + 1.05);

  function makeOsc(freq, startT, dur){
    const osc = intCtx.createOscillator();
    osc.type = "sine";
    osc.frequency.setValueAtTime(freq, startT);

    const g = intCtx.createGain();
    g.gain.value = 0.0001;

    osc.connect(g);
    g.connect(master);

    g.gain.setValueAtTime(0.0001, startT);
    g.gain.exponentialRampToValueAtTime(1.0, startT + 0.01);
    g.gain.setValueAtTime(1.0, startT + Math.max(0.05, dur - 0.02));
    g.gain.exponentialRampToValueAtTime(0.0001, startT + dur);

    osc.start(startT);
    osc.stop(startT + dur);
    return osc;
  }

  const mode = intCurrent.mode;

  if(mode === "Ascending"){
    const dur = 0.35;
    const gap = 0.07;
    const a = makeOsc(rootF, now + 0.02, dur);
    const b = makeOsc(intF,  now + 0.02 + dur + gap, dur);
    intLast = [a,b];
  } else if(mode === "Descending"){
    const dur = 0.35;
    const gap = 0.07;
    const a = makeOsc(intF,  now + 0.02, dur);
    const b = makeOsc(rootF, now + 0.02 + dur + gap, dur);
    intLast = [a,b];
  } else {
    const dur = 0.7;
    const a = makeOsc(rootF, now + 0.02, dur);
    const b = makeOsc(intF,  now + 0.02, dur);
    intLast = [a,b];
  }

  intReplayBtn.disabled = false;
}

function intSelectAnswer(btn, opt){
  if(intLocked) return;
  intLocked = true;
  intAnswered++;

  const buttons = [...document.querySelectorAll("#intAnswers .answer")];
  buttons.forEach(b => b.disabled = true);

  const isCorrect = (opt.id === intCurrent.interval.id);

  if(isCorrect){
    intScore++; intCorrect++;
    btn.classList.add("correct");
    intFeedbackEl.innerHTML = `‚úÖ Correct ‚Äî <b>${intCurrent.interval.label}</b>`;
  } else {
    btn.classList.add("wrong");
    intFeedbackEl.innerHTML = `‚ùå Incorrect ‚Äî Correct answer was <b>${intCurrent.interval.label}</b>`;
    buttons.forEach(b=>{ if(b.textContent === intCurrent.interval.label) b.classList.add("correct"); });
  }

  intUpdateStats();
  intNextBtn.disabled = false;
}

intPlayBtn.onclick = () => { if(!intCurrent) intNewQuestion(); intPlayInterval(); };
intReplayBtn.onclick = () => intPlayInterval();
intNextBtn.onclick = () => {
  if(intAnswered >= INT_TOTAL_Q){
    intFeedbackEl.innerHTML = `üéâ Finished! Final Score: <b>${intScore}/${INT_TOTAL_Q}</b>`;
    intNextBtn.disabled = true;
    return;
  }
  intNewQuestion();
};
intResetBtn.onclick = () => { intScore = 0; intAnswered = 0; intCorrect = 0; intUpdateStats(); intNewQuestion(); };
intModeBtn.onclick = () => { intModeIndex = (intModeIndex + 1) % INT_MODES.length; intUpdateStats(); };

intUpdateStats();
intNewQuestion();

/* =====================================================
   SECTION 4: STEREO vs MONO IDENTIFICATION
===================================================== */
const ST_TOTAL_Q = 30;
const ST_LOOP_LEN = 4.0;
const ST_NOISE_LEN = 1.9;

const ST_TYPES = [
  { id:"mono",     label:"Mono" },
  { id:"dualmono", label:"Dual Mono" },
  { id:"wide",     label:"Wide Stereo" },
  { id:"hardpan",  label:"Hard Pan" }
];

let stScore = 0, stAnswered = 0, stCorrect = 0;
let stLocked = false;
let stCurrent = null;
let stLastSources = null;

let stCtx = null;
let stNoiseL = null;
let stNoiseR = null;

let stTrackBuffer = null;
let stUseTrack = false;

let stLoopStart = 0;
const stLoopSlider = document.getElementById("stLoop");
const stLoopTime = document.getElementById("stLoopTime");
const stPreviewBtn = document.getElementById("stPreview");

const stScoreEl = document.getElementById("stScore");
const stQnumEl  = document.getElementById("stQnum");
const stAccEl   = document.getElementById("stAcc");
const stAnswersEl = document.getElementById("stAnswers");
const stFeedbackEl = document.getElementById("stFeedback");

const stUseNoiseBtn = document.getElementById("stUseNoiseBtn");
const stUseTrackBtn = document.getElementById("stUseTrackBtn");
const stLoadBtn = document.getElementById("stLoadBtn");
const stFile = document.getElementById("stFile");
const stTrackLabel = document.getElementById("stTrackLabel");

function stUpdateStats(){
  stScoreEl.textContent = String(stScore);
  stQnumEl.textContent = String(Math.min(stAnswered + 1, ST_TOTAL_Q));
  const pct = stAnswered === 0 ? 0 : Math.round((stCorrect / stAnswered) * 100);
  stAccEl.textContent = pct + "%";
}

function stEnsureAudio(){
  if(stCtx) return;
  stCtx = new (window.AudioContext || window.webkitAudioContext)();

  // noise buffers (2.5s)
  const seconds = 2.5;
  const length = Math.floor(stCtx.sampleRate * seconds);

  function makeNoiseBuffer(){
    const buffer = stCtx.createBuffer(1, length, stCtx.sampleRate);
    const out = buffer.getChannelData(0);

    let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
    for(let i=0;i<length;i++){
      const white = Math.random()*2 - 1;
      b0 = 0.99886*b0 + white*0.0555179;
      b1 = 0.99332*b1 + white*0.0750759;
      b2 = 0.96900*b2 + white*0.1538520;
      b3 = 0.86650*b3 + white*0.3104856;
      b4 = 0.55000*b4 + white*0.5329522;
      b5 = -0.7616*b5 - white*0.0168980;
      const pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white*0.5362;
      b6 = white*0.115926;
      out[i] = pink * 0.10;
    }
    return buffer;
  }

  stNoiseL = makeNoiseBuffer();
  stNoiseR = makeNoiseBuffer();
}

function stStop(){
  try{
    if(stLastSources){
      stLastSources.forEach(s => { try{ s.stop(); }catch(e){} });
      stLastSources = null;
    }
  }catch(e){}
}

function stBuildAnswers(){
  stAnswersEl.innerHTML = "";
  const options = shuffle(ST_TYPES);
  options.forEach(opt => {
    const b = document.createElement("button");
    b.className = "answer";
    b.textContent = opt.label;
    b.onclick = () => stSelectAnswer(b, opt);
    stAnswersEl.appendChild(b);
  });
}

function stNewQuestion(){
  stLocked = false;
  stFeedbackEl.textContent = "";
  document.getElementById("stNext").disabled = true;
  document.getElementById("stReplay").disabled = true;

  const t = ST_TYPES[Math.floor(Math.random() * ST_TYPES.length)];
  const panSide = (t.id === "hardpan") ? (Math.random() < 0.5 ? "L" : "R") : null;
  stCurrent = { typeId: t.id, panSide };

  stBuildAnswers();
  [...document.querySelectorAll("#stAnswers .answer")].forEach(b=>{
    b.disabled = false;
    b.classList.remove("correct","wrong");
  });

  stUpdateStats();
}

function stSelectAnswer(btn, opt){
  if(stLocked) return;
  stLocked = true;
  stAnswered++;

  const buttons = [...document.querySelectorAll("#stAnswers .answer")];
  buttons.forEach(b => b.disabled = true);

  const correctType = stCurrent.typeId;
  const isCorrect = (opt.id === correctType);

  if(isCorrect){
    stScore++; stCorrect++;
    btn.classList.add("correct");
    stFeedbackEl.innerHTML = `‚úÖ Correct ‚Äî <b>${ST_TYPES.find(x=>x.id===correctType).label}</b>`;
  } else {
    btn.classList.add("wrong");
    const corrLabel = ST_TYPES.find(x=>x.id===correctType).label;
    stFeedbackEl.innerHTML = `‚ùå Incorrect ‚Äî Correct answer was <b>${corrLabel}</b>`;
    buttons.forEach(b=>{ if(b.textContent === corrLabel) b.classList.add("correct"); });
  }

  stUpdateStats();
  document.getElementById("stNext").disabled = false;
}

function stConfigureLoopUI(){
  const hasTrack = !!stTrackBuffer;
  const loopLen = hasTrack ? Math.min(ST_LOOP_LEN, stTrackBuffer.duration) : ST_LOOP_LEN;

  if(hasTrack){
    const maxStart = Math.max(0, stTrackBuffer.duration - loopLen);
    stLoopStart = clamp(stLoopStart, 0, maxStart);

    stLoopSlider.disabled = false;
    stLoopSlider.min = "0";
    stLoopSlider.max = String(maxStart);
    stLoopSlider.step = "0.01";
    stLoopSlider.value = String(stLoopStart);
    stLoopTime.textContent = fmtTime(stLoopStart);
    stPreviewBtn.disabled = !stUseTrack;
  } else {
    stLoopStart = 0;
    stLoopSlider.disabled = true;
    stLoopSlider.min = "0";
    stLoopSlider.max = "0";
    stLoopSlider.value = "0";
    stLoopTime.textContent = "0.00s";
    stPreviewBtn.disabled = true;
  }
}

stLoopSlider.oninput = (e) => {
  stLoopStart = parseFloat(e.target.value || "0");
  stLoopTime.textContent = fmtTime(stLoopStart);
};

function stGetTrackOrNoiseSources(){
  if(stUseTrack && stTrackBuffer){
    const src = stCtx.createBufferSource();
    src.buffer = stTrackBuffer;
    const isStereo = (stTrackBuffer.numberOfChannels && stTrackBuffer.numberOfChannels >= 2);
    return { mode:"track", sources:[src], isStereoTrack:isStereo };
  }

  const l = stCtx.createBufferSource(); l.buffer = stNoiseL;
  const r = stCtx.createBufferSource(); r.buffer = stNoiseR;
  return { mode:"noise", sources:[l,r], isStereoTrack:true };
}

/*
  Play modes:
  - "STEREO" normal
  - "L" left-only monitor
  - "R" right-only monitor
*/
function stPlay(monitor="STEREO"){
  stEnsureAudio();
  stStop();
  if(!stCurrent) stNewQuestion();
  if(stCtx.state === "suspended") stCtx.resume();

  const now = stCtx.currentTime;
  const startT = now + 0.02;

  const usingTrack = (stUseTrack && stTrackBuffer);
  const segLen = usingTrack ? Math.min(ST_LOOP_LEN, stTrackBuffer.duration) : ST_NOISE_LEN;
  const endT = startT + segLen;

  const master = stCtx.createGain();
  master.gain.value = 0.0001;
  master.connect(stCtx.destination);

  master.gain.setValueAtTime(0.0001, now);
  master.gain.exponentialRampToValueAtTime(0.85, startT + 0.03);
  master.gain.setValueAtTime(0.85, endT - 0.08);
  master.gain.exponentialRampToValueAtTime(0.0001, endT);

  const { mode, sources, isStereoTrack } = stGetTrackOrNoiseSources();

  const merger = stCtx.createChannelMerger(2);
  const splitter = stCtx.createChannelSplitter(2);
  const postMerger = stCtx.createChannelMerger(2);

  merger.connect(splitter);

  const postGL = stCtx.createGain(); postGL.gain.value = (monitor === "R") ? 0.0001 : 1.0;
  const postGR = stCtx.createGain(); postGR.gain.value = (monitor === "L") ? 0.0001 : 1.0;

  splitter.connect(postGL, 0);
  splitter.connect(postGR, 1);

  postGL.connect(postMerger, 0, 0);
  postGR.connect(postMerger, 0, 1);

  postMerger.connect(master);

  const typeId = stCurrent.typeId;

  function connectMonoToLR(node, lGain, rGain, lDelay=0, rDelay=0){
    const gL = stCtx.createGain(); gL.gain.value = lGain;
    const gR = stCtx.createGain(); gR.gain.value = rGain;

    let leftNode = node;
    let rightNode = node;

    if(lDelay > 0){
      const dL = stCtx.createDelay(0.05);
      dL.delayTime.value = lDelay;
      leftNode.connect(dL);
      leftNode = dL;
    }
    if(rDelay > 0){
      const dR = stCtx.createDelay(0.05);
      dR.delayTime.value = rDelay;
      rightNode.connect(dR);
      rightNode = dR;
    }

    leftNode.connect(gL);
    rightNode.connect(gR);

    gL.connect(merger, 0, 0);
    gR.connect(merger, 0, 1);
  }

  function connectStereoWithType(trackSrc){
    const split = stCtx.createChannelSplitter(2);
    trackSrc.connect(split);

    const l = stCtx.createGain(); l.gain.value = 1.0;
    const r = stCtx.createGain(); r.gain.value = 1.0;

    split.connect(l, 0);
    split.connect(r, 1);

    if(typeId === "mono"){
      const sum = stCtx.createGain(); sum.gain.value = 0.5;
      l.connect(sum); r.connect(sum);
      connectMonoToLR(sum, 1.0, 1.0);
      return;
    }

    if(typeId === "dualmono"){
      const sum = stCtx.createGain(); sum.gain.value = 0.5;
      l.connect(sum); r.connect(sum);
      connectMonoToLR(sum, 0.92, 1.0, 0, 0.004);
      return;
    }

    if(typeId === "hardpan"){
      const side = stCurrent.panSide || "L";
      const gL = stCtx.createGain(); gL.gain.value = (side === "L") ? 1.0 : 0.0001;
      const gR = stCtx.createGain(); gR.gain.value = (side === "R") ? 1.0 : 0.0001;
      l.connect(gL); r.connect(gR);
      gL.connect(merger, 0, 0);
      gR.connect(merger, 0, 1);
      return;
    }

    // wide stereo: simple M/S widening
    const mid = stCtx.createGain(); mid.gain.value = 0.5;
    const sideL = stCtx.createGain(); sideL.gain.value = 0.5;
    const sideR = stCtx.createGain(); sideR.gain.value = -0.5;

    l.connect(mid); r.connect(mid);
    l.connect(sideL); r.connect(sideR);

    const sideSum = stCtx.createGain(); sideSum.gain.value = 1.0;
    sideL.connect(sideSum);
    sideR.connect(sideSum);

    const sideGain = stCtx.createGain(); sideGain.gain.value = 1.6;
    sideSum.connect(sideGain);

    const sideInv = stCtx.createGain(); sideInv.gain.value = -1.0;
    sideGain.connect(sideInv);

    const outL = stCtx.createGain(); outL.gain.value = 1.0;
    const outR = stCtx.createGain(); outR.gain.value = 1.0;

    mid.connect(outL); sideGain.connect(outL);
    mid.connect(outR); sideInv.connect(outR);

    outL.connect(merger, 0, 0);
    outR.connect(merger, 0, 1);
  }

  function connectMonoTrackWithType(trackSrc){
    if(typeId === "mono"){
      connectMonoToLR(trackSrc, 1.0, 1.0);
      return;
    }
    if(typeId === "dualmono"){
      connectMonoToLR(trackSrc, 0.92, 1.0, 0, 0.004);
      return;
    }
    if(typeId === "hardpan"){
      const side = stCurrent.panSide || "L";
      connectMonoToLR(trackSrc, side === "L" ? 1.0 : 0.0001, side === "R" ? 1.0 : 0.0001);
      return;
    }
    // wide for mono: Haas
    connectMonoToLR(trackSrc, 1.0, 0.92, 0, 0.012);
  }

  if(mode === "noise"){
    const srcL = sources[0];
    const srcR = sources[1];

    if(typeId === "mono"){
      connectMonoToLR(srcL, 1.0, 1.0);
    } else if(typeId === "dualmono"){
      connectMonoToLR(srcL, 0.92, 1.0, 0, 0.004);
    } else if(typeId === "hardpan"){
      const side = stCurrent.panSide || "L";
      connectMonoToLR(srcL, side === "L" ? 1.0 : 0.0001, side === "R" ? 1.0 : 0.0001);
    } else {
      const gL = stCtx.createGain(); gL.gain.value = 1.0;
      const gR = stCtx.createGain(); gR.gain.value = 1.0;
      srcL.connect(gL); gL.connect(merger, 0, 0);
      srcR.connect(gR); gR.connect(merger, 0, 1);
    }

    sources.forEach(s => { s.start(startT); s.stop(endT + 0.02); });
    stLastSources = sources;
  } else {
    const trackSrc = sources[0];
    const isStereo = isStereoTrack;

    if(isStereo) connectStereoWithType(trackSrc);
    else connectMonoTrackWithType(trackSrc);

    // start from loop point for exactly segLen seconds
    const loopLen = Math.min(ST_LOOP_LEN, stTrackBuffer.duration);
    const maxStart = Math.max(0, stTrackBuffer.duration - loopLen);
    const offset = clamp(stLoopStart, 0, maxStart);

    trackSrc.start(startT, offset, loopLen);
    trackSrc.stop(endT + 0.02);

    stLastSources = [trackSrc];
  }

  document.getElementById("stReplay").disabled = false;
}

document.getElementById("stPlay").onclick = () => stPlay("STEREO");
document.getElementById("stReplay").onclick = () => stPlay("STEREO");
document.getElementById("stPlayL").onclick = () => stPlay("L");
document.getElementById("stPlayR").onclick = () => stPlay("R");

document.getElementById("stNext").onclick = () => {
  if(stAnswered >= ST_TOTAL_Q){
    stFeedbackEl.innerHTML = `üéâ Finished! Final Score: <b>${stScore}/${ST_TOTAL_Q}</b>`;
    document.getElementById("stNext").disabled = true;
    return;
  }
  stNewQuestion();
};

document.getElementById("stReset").onclick = () => {
  stScore = 0; stAnswered = 0; stCorrect = 0;
  stUpdateStats();
  stNewQuestion();
};

function stRefreshToggleUI(){
  stUseNoiseBtn.classList.toggle("active", !stUseTrack);
  stUseTrackBtn.classList.toggle("active", !!stUseTrack);
  if(stUseTrack && !stTrackBuffer) stTrackLabel.textContent = "No track loaded";
  stConfigureLoopUI();
}

stUseNoiseBtn.onclick = () => { stUseTrack = false; stRefreshToggleUI(); };
stUseTrackBtn.onclick = () => { stUseTrack = true;  stRefreshToggleUI(); };

stLoadBtn.onclick = () => { stEnsureAudio(); stFile.click(); };

stFile.onchange = async (e) => {
  const file = e.target.files?.[0];
  if(!file) return;
  stEnsureAudio();
  try{
    stTrackLabel.textContent = "Loading‚Ä¶";
    const buf = await decodeFileToBuffer(file, stCtx);
    stTrackBuffer = buf;
    stUseTrack = true;
    stTrackLabel.textContent = file.name;
    stLoopStart = 0;
    stRefreshToggleUI();
  }catch(err){
    stTrackBuffer = null;
    stTrackLabel.textContent = "Could not load track";
    stFeedbackEl.innerHTML = `‚ö†Ô∏è Could not decode this file. Try WAV/MP3.`;
    stUseTrack = false;
    stRefreshToggleUI();
  }
};

stPreviewBtn.onclick = () => {
  if(!stTrackBuffer) return;
  stUseTrack = true;
  stRefreshToggleUI();
  // preview current loop without ‚Äútype‚Äù confusion: just play with current question‚Äôs type,
  // but it's still useful as a consistency check. If you'd prefer "clean stereo preview",
  // tell me and I'll add a separate preview mode.
  stPlay("STEREO");
};

stUpdateStats();
stNewQuestion();

/* =====================================================
   START / PREP
===================================================== */
showView("menu");
newQuestion();

eqBuildAnswerButtons();
eqUpdateStats();
eqNewQuestion();
eqRefreshToggleUI();

stRefreshToggleUI();
</script>
</body>
</html>
